<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线性表的顺序存储（c++）</title>
      <link href="/archives/b4bd089e.html"/>
      <url>/archives/b4bd089e.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是顺序表"><a href="#什么是顺序表" class="headerlink" title="什么是顺序表"></a>什么是顺序表</h1><ul><li>一个最简单的例子就是一维数组，它的特点就是在内存中进行<strong>顺序存储</strong></li><li>在一块内存中，进行顺序存储的线性表就是顺序表</li><li>在任意时刻，数组的长度就是顺序表的最大存储容量</li></ul><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef _DEBUG//只有在Debug（调试）模式下</span></span><br><span class="line"><span class="comment">#ifndef DEBUG_NEW</span></span><br><span class="line"><span class="comment">#define DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__)//重新定义new运算符</span></span><br><span class="line">//当进行对象转储时，用 DEBUG_NEW 分配的每个对象均将显示被分配到的文件和行号，使您可以查明内存泄漏源</span><br><span class="line"><span class="comment">#define new DEBUG_NEW    </span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment"># pragma warning(disable : 4996)</span></span><br><span class="line"><span class="comment">#define InitSize 10//动态数组的初始大小</span></span><br><span class="line"><span class="comment">#define IncSize 5//当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span><br></pre></td></tr></table></figure><hr><h1 id="顺序表的数据成员-两种写法"><a href="#顺序表的数据成员-两种写法" class="headerlink" title="顺序表的数据成员(两种写法)"></a>顺序表的数据成员(两种写法)</h1><ul><li><p>静态数组</p><ul><li><p>建立一个一维数组，来保存顺序表的元素</p></li><li><p>建立一个变量存储顺序表当前的实际长度（不是数组的长度，数组长度是已知的）</p></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">int m_data[10];  //静态数组保存顺序表中的元素，一共10个位置</span><br><span class="line">int m_length;//顺序表中当前的实际长度</span><br><span class="line"></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure><ul><li>动态数组（通常都采用这种写法）<ul><li>用指针进行建立数组内存</li><li>动态数组可以进行扩容</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">int* m_data;       //顺序表中的元素保存在m_data所指向的动态数组内存中</span><br><span class="line">int m_length;//顺序表当前的实际长度</span><br><span class="line">int m_maxsize;//动态数组最大容量，因为动态数组可以扩容，因此要记录该值</span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure><hr><h1 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h1><ul><li>顺序表的类的定义和设计<ul><li>构造函数</li><li>析构函数</li><li>按指定位置i插入元素</li><li>按指定位置i删除元素</li><li>获取第i位置的元素</li><li>按元素值查找在顺序表的第一次出现的位置</li><li>遍历输出顺序表的元素</li><li>获取顺序表的长度</li><li>反转顺序表</li><li>扩容操作</li></ul></li></ul><hr><h1 id="顺序表的编程实现"><a href="#顺序表的编程实现" class="headerlink" title="顺序表的编程实现"></a>顺序表的编程实现</h1><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">namespace _nmsp1</span><br><span class="line">&#123;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class SeqList</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">SeqList(int length = InitSize);//构造函数</span><br><span class="line">~SeqList();//析构函数</span><br><span class="line">public:</span><br><span class="line">bool List_Insert(int i, const T&amp; e);//在第i个位置插入新元素</span><br><span class="line">bool List_Delete(int i);//删除第i个位置的元素</span><br><span class="line">bool Get_List_Elem(int i, const T&amp; e);//获取第i个位置的元素</span><br><span class="line">int Locate_Elem(const T&amp; e);//按元素值查找在顺序表的第一次出现的位置</span><br><span class="line">void Display_List();//输出顺序表中的元素</span><br><span class="line">int Get_List_Length();//获取顺序表的长度</span><br><span class="line">void Reverse_List();//反转顺序表</span><br><span class="line">void Increase_Size();//扩容操作</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">T* m_data;//（指向存放顺序表的当中的元素</span><br><span class="line">int m_length;//顺序表中当前实际长度（当前有几个元素）</span><br><span class="line">int m_maxsize;//动态数组的最大容量</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="构造函数（初始化）"><a href="#构造函数（初始化）" class="headerlink" title="构造函数（初始化）"></a>构造函数（初始化）</h2><ul><li>首先会开辟一块内存来存储顺序表</li><li>为当前顺序表长度赋初值为0</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//通过构造函数对顺序表进行初始化template &lt;typename T&gt;</span><br><span class="line">SeqList&lt;T&gt;::SeqList(int length)</span><br><span class="line">&#123;</span><br><span class="line">m_data = new T[length]; //为一维数组动态分配内存</span><br><span class="line">m_length = 0;           //顺序表当前实际长度为0，表示还未向其中存入任何数据元素</span><br><span class="line">m_maxsize = length;     //顺序表最多可以存储m_maxsize个数据元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul><li>必须对用户自己分配好的内存空间进行释放</li><li><strong>delete m_data 和delete []m_data的区别</strong><ul><li>delete m_data <strong>释放了m_data指针指向的全部内存空间 但是只调用了m_data[0]对象的析构函数 剩下的从[1]到末尾这个用户自行分配的对应内存空间将不能释放</strong>， 从而造成内存泄漏。</li><li>delete []m_data <strong>&#x2F;调用使用类对象的析构函数释放用户自己分配内存空间并且  释放了m_data指针指向的全部内存空间</strong></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//通过析构函数对顺序表进行资源释放</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">SeqList&lt;T&gt;::~<span class="function"><span class="title">SeqList</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">delete[] m_data;</span><br><span class="line">m_length = 0; //非必须</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="按指定位置i插入元素"><a href="#按指定位置i插入元素" class="headerlink" title="按指定位置i插入元素"></a>按指定位置i插入元素</h2><ol><li><p>先判断顺序表是否存满数据；是，进行扩容操作</p></li><li><p>判断i这个位置是否合法</p></li><li><p>以上都满足进行插入操作</p><ul><li><p>从最后一个元素遍历到下标为i的位置（也就是第i+1个元素）结束进行元素位置向后移位</p></li><li><p>对第i个位置进行赋值</p></li><li><p>每一次进行插入 操作，顺序表长+1</p></li></ul></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//在第i个位置（位置编号从1开始）插入指定元素e，时间复杂度：O(n)</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool SeqList&lt;T&gt;::ListInsert(int i, const T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">//如果顺序表已经存满了数据，则不允许再插入新数据了</span><br><span class="line"><span class="keyword">if</span> (m_length &gt;= m_maxsize)</span><br><span class="line">&#123;</span><br><span class="line">//cout &lt;&lt; <span class="string">&quot;顺序表已满，不能再进行插入操作了!&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">//return false;</span></span><br><span class="line"><span class="string">IncreaseSize();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//判断插入位置i是否合法，i的合法值应该是1到m_length+1之间</span></span><br><span class="line"><span class="string">if(i &lt; 1 || i &gt; (m_length+1))</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;元素&quot; &lt;&lt; e &lt;&lt;&quot;插入的位置&quot; &lt;&lt; i &lt;&lt; &quot;不合法，合法的位置是1到&quot; &lt;&lt;   m_length+1 &lt;&lt; &quot;之间!&quot; &lt;&lt; endl</span>;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从最后一个元素开始向前遍历到要插入新元素的第i个位置，</span><br><span class="line">//分别将这些位置中原有的元素向后移动一个位置</span><br><span class="line"><span class="keyword">for</span> (int j = m_length; j &gt;= i; --j) </span><br><span class="line">&#123;</span><br><span class="line">m_data[j] = m_data[j-1];</span><br><span class="line">&#125;</span><br><span class="line">m_data[i-1] = e;   //在指定位置i处插入元素e</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; <span class="string">i &lt;&lt; &quot;处插入元素&quot; &lt;&lt; m_data[i</span> - 1] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">m_length++;        //实际表长+1</span></span><br><span class="line"><span class="string">return true;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="按指定位置i删除元素"><a href="#按指定位置i删除元素" class="headerlink" title="按指定位置i删除元素"></a>按指定位置i删除元素</h2><ul><li>判断表是否为空</li><li>判断位置i是否合法</li><li>以上都满足，遍历第i+1个位置到顺序表末尾向前移位</li><li>每次删除操作顺序表长都必须-1</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//删除第i个位置的元素</span><br><span class="line">template &lt; typename T&gt;</span><br><span class="line">bool SeqList&lt;T&gt;::ListDelete(int i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; 1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序表为空，不能删除任何数据!&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">return false;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">if (i &lt; 1 || i &gt; m_length)</span></span><br><span class="line"><span class="string">&#123; </span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;删除的位置&quot; &lt;&lt; i &lt;&lt; &quot;不合法，合法的位置是1到&quot; &lt;&lt; m_length &lt;&lt; &quot;之间!&quot; &lt;&lt; endl</span>;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; <span class="string">i &lt;&lt; &quot;的元素，该元素的值为&quot; &lt;&lt; m_data[i</span> - 1] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">//从数组中第i+1个位置开始向后遍历所有元素，分别将这些位置中原有的元素向前移动一个位置</span></span><br><span class="line"><span class="string">for (int j = i ; j &lt; m_length; ++j)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">m_data[j-1] = m_data[j];</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">m_length--;       //实际表长-1</span></span><br><span class="line"><span class="string">return true;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="获取第i个位置的元素值"><a href="#获取第i个位置的元素值" class="headerlink" title="获取第i个位置的元素值"></a>获取第i个位置的元素值</h2><ul><li>判断表是否为空</li><li>判断位置i是否合法</li><li>以上都满足，成功获取值</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//获得第i个位置的元素值</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool SeqList&lt;T&gt;::GetElem(int i, T&amp; e) //参数e是引用类型参数，确保将该值带回调用者</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; 1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序表为空，不能获取任何数据!&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">return false;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if (i &lt; 1 || i &gt; m_length)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;获取元素的位置&quot; &lt;&lt; i &lt;&lt; &quot;不合法，合法的位置是1到&quot; &lt;&lt; m_length &lt;&lt;   &quot;之间!&quot; &lt;&lt; endl</span>;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = m_data[i-1];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; <span class="string">i &lt;&lt; &quot;的元素，该元素的值为&quot; &lt;&lt; m_data[i</span> - 1] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">return true;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h2 id="按元素值查找在顺序表的第一次出现的位置"><a href="#按元素值查找在顺序表的第一次出现的位置" class="headerlink" title="按元素值查找在顺序表的第一次出现的位置"></a>按元素值查找在顺序表的第一次出现的位置</h2><ul><li>是按照元素值进行查找，则对其全部进行遍历一一对比</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//按元素值查找其在顺序表中第一次出现的位置</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int SeqList&lt;T&gt;::LocateElem(const T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_data[i] == e)</span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; <span class="string">e &lt;&lt; &quot;的元素在顺序表中第一次出现的位置为&quot; &lt;&lt; i+1 &lt;&lt; &quot;!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">return i + 1;  //返回的位置应该用数组下标值+1</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;值为&quot; &lt;&lt; e</span> &lt;&lt; <span class="string">&quot;的元素在顺序表中没有找到!&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">return -1;  //返回-1表示查找失败</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><hr><h2 id="遍历输出顺序表的元素"><a href="#遍历输出顺序表的元素" class="headerlink" title="遍历输出顺序表的元素"></a>遍历输出顺序表的元素</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//输出顺序表中的所有元素，时间复杂度为O(n)</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void SeqList&lt;T&gt;::<span class="function"><span class="title">DispList</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">m_data[i] &lt;&lt; &quot; &quot;;  //每个数据之间以空格分隔</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout &lt;&lt; endl; //换行</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="获取顺序表的长度"><a href="#获取顺序表的长度" class="headerlink" title="获取顺序表的长度"></a>获取顺序表的长度</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//获取顺序表的长度，时间复杂度为O(1)</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int SeqList&lt;T&gt;::<span class="function"><span class="title">ListLength</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> m_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="反转顺序表"><a href="#反转顺序表" class="headerlink" title="反转顺序表"></a>反转顺序表</h2><ul><li>判断顺序是否为空</li><li>第一个和最后一个交换赋值，依次类推</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//翻转顺序表，时间复杂度为O(n)</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void SeqList&lt;T&gt;::<span class="function"><span class="title">ReverseList</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt;= 1)</span><br><span class="line">&#123;</span><br><span class="line">//如果没有顺序表中没有元素或者只有一个元素，那么就不用做任何操作</span><br><span class="line"><span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">T temp;</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; m_length / 2; ++i)</span><br><span class="line">&#123;</span><br><span class="line">temp = m_data[i];</span><br><span class="line">m_data[i] = m_data[m_length - i - 1];</span><br><span class="line">m_data[m_length - i - 1] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h2><ul><li>新建一个指针指向原来顺序表的数据的内存块</li><li>新开辟一个内存的同时要扩容一下大小</li><li>然后在遍历原来内存将其数据复制到已经新的内存（新扩容的内存）</li><li>释放原来的内存块</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//当顺序表存满数据后可以调用此函数为顺序表扩容，时间复杂度为O(n)</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void SeqList&lt;T&gt;::<span class="function"><span class="title">IncreaseSize</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">T* p = m_data;</span><br><span class="line">m_data = new T[m_maxsize + IncSize]; //重新为顺序表分配更大的内存空间</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; m_length; i++)</span><br><span class="line">&#123;</span><br><span class="line">m_data[i] = p[i];                //将数据复制到新区域</span><br><span class="line">&#125;</span><br><span class="line">m_maxsize = m_maxsize + IncSize;     //顺序表最大长度增加IncSize</span><br><span class="line">delete[] p;                          //释放原来的内存空间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主函数操作"><a href="#主函数操作" class="headerlink" title="主函数操作"></a>主函数操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line">//程序退出时检测内存泄漏并显示到“输出”窗口</span><br><span class="line"></span><br><span class="line">_nmsp1::SeqList&lt;int&gt; seqobj(10);</span><br><span class="line">seqobj.ListInsert(1, 15);</span><br><span class="line">seqobj.ListInsert(2, 10);</span><br><span class="line">seqobj.ListInsert(30, 8);</span><br><span class="line"></span><br><span class="line">seqobj.ListDelete(1);</span><br><span class="line"></span><br><span class="line">int <span class="built_in">eval</span> = 0;</span><br><span class="line">seqobj.GetElem(1, <span class="built_in">eval</span>); //如果GetElem()返回<span class="literal">true</span>，则<span class="built_in">eval</span>中保存着获取到的元素值</span><br><span class="line"></span><br><span class="line">int findvalue = 10; //在顺序表中要找的元素值</span><br><span class="line">seqobj.LocateElem(findvalue);</span><br><span class="line"></span><br><span class="line">//-------------------------------</span><br><span class="line">seqobj.ListInsert(2, 100);</span><br><span class="line">seqobj.DispList();</span><br><span class="line">cout &lt;&lt; <span class="string">seqobj.ListLength() &lt;&lt; endl;</span></span><br><span class="line"><span class="string">seqobj</span>.ReverseList();</span><br><span class="line">seqobj.DispList();</span><br><span class="line"></span><br><span class="line">//-----------------------</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">for (int i = 3; i &lt; 30; ++i)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">seqobj.ListInsert(i, i*2);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">seqobj.DispList();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><hr><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>顺序表的特点</p><ul><li>通过下标访问数据元素的时间复杂度为O（1）</li><li>插入和删除操作会移动大量元素时间复杂度为O（n）</li><li>需要大片的连续的内存空间来存储数据</li><li>扩容操作的具体数值的大小不好确定（大了导致内存浪费，小了会进行频繁的操作）</li></ul></li><li><p>应用：</p><ul><li>vector  大致思想原理是类似于顺序表</li></ul></li></ul><hr><h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef _DEBUG   //只在Debug（调试）模式下</span></span><br><span class="line"><span class="comment">#ifndef DEBUG_NEW</span></span><br><span class="line"><span class="comment">#define DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) //重新定义new运算符</span></span><br><span class="line"><span class="comment">#define new DEBUG_NEW</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">//<span class="comment">#include &lt;boost/type_index.hpp&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">//<span class="comment">#pragma warning(disable : 4996) </span></span><br><span class="line"></span><br><span class="line">namespace _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define InitSize 10   //动态数组的初始尺寸</span></span><br><span class="line"><span class="comment">#define IncSize  5    //当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; //T代表数组中元素的类型</span><br><span class="line">class SeqList</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">SeqList(int length=InitSize); //构造函数，参数可以有默认值</span><br><span class="line">~SeqList();                   //析构函数</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">bool ListInsert(int i, const T&amp; e);  //在第i个位置插入指定元素e</span><br><span class="line">bool ListDelete(int i);              //删除第i个位置的元素</span><br><span class="line">bool GetElem(int i, T&amp; e);           //获得第i个位置的元素值</span><br><span class="line">int  LocateElem(const T &amp;e);         //按元素值查找其在顺序表中第一次出现的位置</span><br><span class="line"></span><br><span class="line">void DispList();                     //输出顺序表中的所有元素</span><br><span class="line">int  ListLength();                   //获取顺序表的长度</span><br><span class="line">void ReverseList();                  //翻转顺序表</span><br><span class="line"></span><br><span class="line">void IncreaseSize();                 //当顺序表存满数据后可以调用此函数为顺序表扩容</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">T*  m_data;                   //存放顺序表中的元素</span><br><span class="line">int m_length;                 //顺序表当前长度（当前有几个元素）</span><br><span class="line">int m_maxsize;                //动态数组最大容量</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//通过构造函数对顺序表进行初始化</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">SeqList&lt;T&gt;::SeqList(int length)</span><br><span class="line">&#123;</span><br><span class="line">m_data = new T[length]; //为一维数组动态分配内存</span><br><span class="line">m_length = 0;           //顺序表当前实际长度为0，表示还未向其中存入任何数据元素</span><br><span class="line">m_maxsize = length;     //顺序表最多可以存储m_maxsize个数据元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过析构函数对顺序表进行资源释放</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">SeqList&lt;T&gt;::~<span class="function"><span class="title">SeqList</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">delete[] m_data;</span><br><span class="line">m_length = 0; //非必须</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在第i个位置（位置编号从1开始）插入指定元素e，时间复杂度：O(n)</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool SeqList&lt;T&gt;::ListInsert(int i, const T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_length &gt;= m_maxsize)</span><br><span class="line">&#123;</span><br><span class="line">//cout &lt;&lt; <span class="string">&quot;顺序表已满，不能再进行插入操作了!&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">//return false;</span></span><br><span class="line"><span class="string">IncreaseSize();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if(i &lt; 1 || i &gt; (m_length+1))</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;元素&quot; &lt;&lt; e &lt;&lt;&quot;插入的位置&quot; &lt;&lt; i &lt;&lt; &quot;不合法，合法的位置是1到&quot; &lt;&lt; m_length+1 &lt;&lt; &quot;之间!&quot; &lt;&lt; endl</span>;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (int j = m_length; j &gt;= i; --j) </span><br><span class="line">&#123;</span><br><span class="line">m_data[j] = m_data[j-1];</span><br><span class="line">&#125;</span><br><span class="line">m_data[i-1] = e;   </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; <span class="string">i &lt;&lt; &quot;处插入元素&quot; &lt;&lt; m_data[i</span> - 1] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">m_length++;        //实际表长+1</span></span><br><span class="line"><span class="string">return true;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//删除第i个位置的元素</span></span><br><span class="line"><span class="string">template &lt; typename T&gt;</span></span><br><span class="line"><span class="string">bool SeqList&lt;T&gt;::ListDelete(int i)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">if (m_length &lt; 1)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;当前顺序表为空，不能删除任何数据!&quot; &lt;&lt; endl</span>;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; 1 || i &gt; m_length)</span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; <span class="string">i &lt;&lt; &quot;不合法，合法的位置是1到&quot; &lt;&lt; m_length &lt;&lt; &quot;之间!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">return false;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;成功删除位置为&quot; &lt;&lt; i</span> &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; <span class="string">m_data[i - 1] &lt;&lt; &quot;!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for (int j = i ; j &lt; m_length; ++j)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">m_data</span>[j-1] = m_data[j];</span><br><span class="line">&#125;</span><br><span class="line">m_length--;       //实际表长-1</span><br><span class="line"><span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获得第i个位置的元素值</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool SeqList&lt;T&gt;::GetElem(int i, T&amp; e) //参数e是引用类型参数，确保将该值带回调用者</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; 1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序表为空，不能获取任何数据!&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">return false;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if (i &lt; 1 || i &gt; m_length)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;获取元素的位置&quot; &lt;&lt; i &lt;&lt; &quot;不合法，合法的位置是1到&quot; &lt;&lt; m_length &lt;&lt; &quot;之间!&quot; &lt;&lt; endl</span>;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = m_data[i-1];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; <span class="string">i &lt;&lt; &quot;的元素，该元素的值为&quot; &lt;&lt; m_data[i</span> - 1] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">return true;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//按元素值查找其在顺序表中第一次出现的位置</span></span><br><span class="line"><span class="string">template&lt;class T&gt;</span></span><br><span class="line"><span class="string">int SeqList&lt;T&gt;::LocateElem(const T&amp; e)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">for (int i = 0; i &lt; m_length; ++i)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">if (m_data[i] == e)</span></span><br><span class="line"><span class="string">&#123; </span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;值为&quot; &lt;&lt; e &lt;&lt; &quot;的元素在顺序表中第一次出现的位置为&quot; &lt;&lt; i+1 &lt;&lt; &quot;!&quot; &lt;&lt; endl</span>;</span><br><span class="line"><span class="built_in">return</span> i + 1;  //返回的位置应该用数组下标值+1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; <span class="string">e &lt;&lt; &quot;的元素在顺序表中没有找到!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">return -1;  //返回-1表示查找失败</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//输出顺序表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="string">template&lt;class T&gt;</span></span><br><span class="line"><span class="string">void SeqList&lt;T&gt;::DispList()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">for (int i = 0; i &lt; m_length; ++i)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">cout &lt;&lt; m_data[i] &lt;&lt; &quot; &quot;;  //每个数据之间以空格分隔</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">cout &lt;&lt; endl; //换行</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//获取顺序表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="string">template&lt;class T&gt;</span></span><br><span class="line"><span class="string">int SeqList&lt;T&gt;::ListLength()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">return m_length;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//翻转顺序表，时间复杂度为O(n)</span></span><br><span class="line"><span class="string">template&lt;class T&gt;</span></span><br><span class="line"><span class="string">void SeqList&lt;T&gt;::ReverseList()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">if (m_length &lt;= 1) </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">return;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">T temp;</span></span><br><span class="line"><span class="string">for (int i = 0; i &lt; m_length / 2; ++i)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">temp = m_data[i];</span></span><br><span class="line"><span class="string">m_data[i] = m_data[m_length - i - 1];</span></span><br><span class="line"><span class="string">m_data[m_length - i - 1] = temp;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//当顺序表存满数据后可以调用此函数为顺序表扩容，时间复杂度为O(n)</span></span><br><span class="line"><span class="string">template&lt;class T&gt;</span></span><br><span class="line"><span class="string">void SeqList&lt;T&gt;::IncreaseSize()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">T* p = m_data;</span></span><br><span class="line"><span class="string">m_data = new T[m_maxsize + IncSize]; //重新为顺序表分配更大的内存空间</span></span><br><span class="line"><span class="string">for (int i = 0; i &lt; m_length; i++)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">m_data[i] = p[i];                //将数据复制到新区域</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">m_maxsize = m_maxsize + IncSize;     //顺序表最大长度增加IncSize</span></span><br><span class="line"><span class="string">delete[] p;                          //释放原来的内存空间</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> //程序退出时检测内存泄漏并显示到“输出”窗口</span></span><br><span class="line"><span class="string">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">_nmsp1::SeqList&lt;int&gt; seqobj(10);</span></span><br><span class="line"><span class="string">seqobj.ListInsert(1, 15);</span></span><br><span class="line"><span class="string">seqobj.ListInsert(2, 10);</span></span><br><span class="line"><span class="string">seqobj.ListInsert(30, 8);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">seqobj.ListDelete(1);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int eval = 0;</span></span><br><span class="line"><span class="string">seqobj.GetElem(1, eval); //如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int findvalue = 10; //在顺序表中要找的元素值</span></span><br><span class="line"><span class="string">seqobj.LocateElem(findvalue);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//-------------------------------</span></span><br><span class="line"><span class="string">seqobj.ListInsert(2, 100);</span></span><br><span class="line"><span class="string">seqobj.DispList();</span></span><br><span class="line"><span class="string">cout &lt;&lt; seqobj.ListLength() &lt;&lt; endl;</span></span><br><span class="line"><span class="string">seqobj.ReverseList();</span></span><br><span class="line"><span class="string">seqobj.DispList();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//-----------------------</span></span><br><span class="line"><span class="string">cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="string">for (int i = 3; i &lt; 30; ++i)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">seqobj.ListInsert(i, i*2);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">seqobj.DispList();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Github+hexo教程</title>
      <link href="/archives/ce550664.html"/>
      <url>/archives/ce550664.html</url>
      
        <content type="html"><![CDATA[<h1 id="搭建GitHub-hexo的博客"><a href="#搭建GitHub-hexo的博客" class="headerlink" title="搭建GitHub+hexo的博客"></a>搭建GitHub+hexo的博客</h1><h2 id="什么是hexo"><a href="#什么是hexo" class="headerlink" title="什么是hexo"></a>什么是hexo</h2><ul><li><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，说的简单一点就是hexo具有markdown程序转换成HTML页面 </p></li><li><p>一般在自己电脑上会创建一个blog文件夹来作为本地仓库，github创建一个仓库，由本地部署到GitHub上面即可通过网址来进行访问。</p></li></ul><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li><p>事先看一遍b站视频</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1mU4y1j72n/spm_id_from=333.337.search-card.all.click   多看看这个视频的准备工作</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.999.0.0</span><br><span class="line">看这个过程进行一步一步的操作</span><br></pre></td></tr></table></figure></li><li><p>安装git （会用的git bash命令行进行操作）  </p></li><li><p>上GitHub官网申请一个账号（并且创建一个仓库）具体操作看第一个视频</p></li><li><p>安装node.js(选择长期版本的)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v  </span><br><span class="line">npm  -v</span><br><span class="line">//显示版本就代表安装成功</span><br><span class="line">npm是一个软件包管理器，在国内速度很慢因此安装cnpm并把指向国内淘宝的镜像源也就是第五步</span><br></pre></td></tr></table></figure></li><li><p>安装cnpm并指向淘宝镜像源</p><p>1. </p>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><p>   <img src="/archives/ce550664/111.png"></p></li></ol><p>安装成功</p><hr><p>出现这种情况，再来一次上面这个命令</p><p><img src="/archives/ce550664/222.png"></p><hr><p><img src="/archives/ce550664/333.png"></p><p>删除c盘下的npmrc文件！！！！ 记住是c盘下的。</p><p>然后在重复命令。</p><hr><ol><li><p>安装hexo框架</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo -cli</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo -v </span><br><span class="line">//显示版本号安装成功</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="搭建本地仓库"><a href="#搭建本地仓库" class="headerlink" title="搭建本地仓库"></a>搭建本地仓库</h1><ol><li><p>建立Blog文件夹（随便在那儿建立，但必须保证是空）</p></li><li><p>在Blog文件下打开git bash</p></li><li><p>hexo init（进行初始化，blog文件夹会显示一系列文件）</p></li><li><p>hexo s</p></li></ol><p><img src="/archives/ce550664/444.png"></p><p>在浏览器输入红色部分会得到一个静态网页。</p><ol start="5"><li><p>hexo n “川的第一篇博客”(创建一个博客，在blog&#x2F;source&#x2F;_posts可以对其文档修改)</p></li><li><p>hexo clean(清理一下缓存)</p></li><li><p>hexo g（生成静态网页）</p></li><li><p>hexo s（运行服务器）</p></li></ol><hr><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><ol><li><p>建立github仓库成功之后</p></li><li><p>在blog文文件夹下装一个部署的插件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li><li><p>修改blog文件夹下的配置文件_config.yml</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">看到<span class="comment">#Deloyment这里进行修改如下图</span></span><br></pre></td></tr></table></figure><p><img src="/archives/ce550664/555.png"></p></li><li><p>hexo d（部署成功）</p></li></ol><hr><hr><h1 id="解决图片不显示问题"><a href="#解决图片不显示问题" class="headerlink" title="解决图片不显示问题"></a>解决图片不显示问题</h1><ul><li>更改配置文件_config.yml</li></ul><p><img src="/archives/ce550664/666.jpg"></p><ul><li>在hexo n ”  xxxx “新建一个博客时，就会产生一个xxxx的文件夹来存储图片以便于在md文件中进行引用图片。</li></ul><p><img src="/archives/ce550664/777.jpg"></p><ul><li><p>再更改一个插件 hexo-asset-image </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/foreveryang321/hexo-asset-image.git --save</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>再按照部署条件进行操作</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>顺序队列和链式队列的实现（c++）</title>
      <link href="/archives/521d054f.html"/>
      <url>/archives/521d054f.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h1><ul><li>队列是一种受限的线性表，其特点是在一端进行插入操作，在另一端进行删除操作；把允许进行插入一端是队尾，允许删除操作的的一端成为队头。</li><li>先进先出，后进后出的特性</li><li>在STL标准库中，有queue（队列）和deque（双端队列）两种容器，双端队列是允许两端都可以进行入队列和出队列操作。</li><li>应用<ul><li>去营业系统办理业务使用的叫号系统</li><li>排队购物</li><li>多个人同时使用网络打印机打印文件</li></ul></li></ul><hr><h1 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h1><h2 id="普通的顺序队列的编程实现"><a href="#普通的顺序队列的编程实现" class="headerlink" title="普通的顺序队列的编程实现"></a>普通的顺序队列的编程实现</h2><ul><li><p>顺序队列与线性表几乎是一致的，不一一进行阐述。</p></li><li><p>缺点：</p><p><img src="https://cdn.jsdelivr.net/gh/chuannihaoa/picog/imageimage-20221127142123700.png" alt="队列演示"></p><ul><li>从上面这张图可以判断该队列并没有完全存满，m_data[0]并没有存满，但是由于该队列只能在队尾插入元素，故m_data[0]就没办法插入，因此就引入循环队列的概念。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SeqQueue</span>();</span><br><span class="line">~<span class="built_in">SeqQueue</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(T&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearQueue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispQueue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_data;</span><br><span class="line"><span class="type">int</span> m_front;<span class="comment">//对头，删除的一端</span></span><br><span class="line"><span class="type">int</span> m_rear;<span class="comment">//队尾，插入的一端</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqQueue&lt;T&gt;::<span class="built_in">SeqQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_data = <span class="keyword">new</span> T[MaxSize];<span class="comment">//为一维动态数组分配内存</span></span><br><span class="line">m_front = <span class="number">0</span>;</span><br><span class="line">m_rear = <span class="number">0</span>;<span class="comment">//空队列，队头和队尾=0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqQueue&lt;T&gt;::~<span class="built_in">SeqQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">EnQueue</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;该队列已满&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">m_data[m_rear] = e;</span><br><span class="line">m_rear++;<span class="comment">//入队列操作队尾指针往后走</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">DeQueue</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;该队列是空的&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">e = m_data[m_front];</span><br><span class="line">m_front++;<span class="comment">//出队列队首指针往后走</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取队头元素，但该元素并没有出队列而是依旧在队列中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序队列为空，不能读取队头元素!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e = m_data[m_front];  <span class="comment">//队头元素返回到e中。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出顺序队列中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqQueue&lt;T&gt;::<span class="built_in">DispQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//按照从对头到队尾的顺序来显示数据</span></span><br><span class="line"><span class="comment">//for (int i = m_front; i &lt; m_rear ; ++i)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = m_front; i != m_rear;)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">i = (i + <span class="number">1</span>) % MaxSize;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取顺序队列的长度（实际拥有的元素数量），时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> SeqQueue&lt;T&gt;::<span class="built_in">QueueLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_rear - m_front;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断顺序队列是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_front == m_rear)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断顺序队列是否已满，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if(m_rear &gt;= MaxSize) //队尾指针和数组容量做比较</span></span><br><span class="line"><span class="keyword">if</span> ((m_rear + <span class="number">1</span>) % MaxSize == m_front)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将队列清空 记住这个特性</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqQueue&lt;T&gt;::<span class="built_in">ClearQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_front = m_rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);<span class="comment">//程序退出时检测内存泄漏并显示到“输出”窗口</span></span><br><span class="line"></span><br><span class="line">_nmsp1::SeqQueue&lt;<span class="type">int</span>&gt; seqobj;</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">150</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">200</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">300</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">400</span>);</span><br><span class="line">seqobj.<span class="built_in">DispQueue</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">seqobj.<span class="built_in">DeQueue</span>(eval);</span><br><span class="line">seqobj.<span class="built_in">DeQueue</span>(eval);</span><br><span class="line">seqobj.<span class="built_in">DispQueue</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------&quot;</span> &lt;&lt; endl;</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">500</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">600</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">700</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">800</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">900</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">1000</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">1100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//seqobj.EnQueue(1200);</span></span><br><span class="line">seqobj.<span class="built_in">DispQueue</span>();</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">1100</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">1100</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">1100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列（顺序）-两种实现方法"><a href="#循环队列（顺序）-两种实现方法" class="headerlink" title="循环队列（顺序）(两种实现方法)"></a>循环队列（顺序）(两种实现方法)</h2><h3 id="牺牲一个保存元素空间的方法"><a href="#牺牲一个保存元素空间的方法" class="headerlink" title="牺牲一个保存元素空间的方法"></a>牺牲一个保存元素空间的方法</h3><ul><li>入队列的改进</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">EnQueue</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;该队列已满&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">m_data[m_rear] = e;</span><br><span class="line"><span class="comment">//m_rear++;</span></span><br><span class="line">m_rear = (m_rear + <span class="number">1</span>) % MaxSize; <span class="comment">//队尾指针加1并取余，这样m_data的下标就控制在了0到(MaxSize-1)之间了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>出队列的改进</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">DeQueue</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;该队列是空的&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">e = m_data[m_front];</span><br><span class="line"><span class="comment">//m_front++;</span></span><br><span class="line">m_front = (m_front + <span class="number">1</span>) % MaxSize;<span class="comment">//引入这段代码</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取顺序队列的长度</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//获取顺序队列的长度（实际拥有的元素数量），时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> SeqQueue&lt;T&gt;::<span class="built_in">QueueLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//return m_rear - m_front;</span></span><br><span class="line"><span class="keyword">return</span> (m_rear + MaxSize - m_front) % MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如何判断队列为空，队列已满</p><ul><li>if(m_front &#x3D;&#x3D; m_rear)判断为空</li><li>队列已满：常用的方法是通过牺牲一个保存元素空间的来判断：假设存储10个元素，但是实际只能村上9个元素就已经判断该队列处于已满的状态，相当于第10个元素用来作为判断的条件。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断顺序队列是否已满，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if(m_rear &gt;= MaxSize) //队尾指针和数组容量做比较</span></span><br><span class="line"><span class="keyword">if</span> ((m_rear + <span class="number">1</span>) % MaxSize == m_front)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全部代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SeqQueue</span>();</span><br><span class="line">~<span class="built_in">SeqQueue</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(T&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearQueue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispQueue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_data;</span><br><span class="line"><span class="type">int</span> m_front;<span class="comment">//对头，删除的一端</span></span><br><span class="line"><span class="type">int</span> m_rear;<span class="comment">//队尾，插入的一端</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqQueue&lt;T&gt;::<span class="built_in">SeqQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_data = <span class="keyword">new</span> T[MaxSize];</span><br><span class="line">m_front = <span class="number">0</span>;</span><br><span class="line">m_rear = <span class="number">0</span>;<span class="comment">//空队列，队头和队尾=0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqQueue&lt;T&gt;::~<span class="built_in">SeqQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">EnQueue</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;该队列已满&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">m_data[m_rear] = e;</span><br><span class="line"><span class="comment">//m_rear++;</span></span><br><span class="line">m_rear = (m_rear + <span class="number">1</span>) % MaxSize; <span class="comment">//队尾指针加1并取余，这样m_data的下标就控制在了0到(MaxSize-1)之间了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">DeQueue</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;该队列是空的&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">e = m_data[m_front];</span><br><span class="line"><span class="comment">//m_front++;</span></span><br><span class="line">m_front = (m_front + <span class="number">1</span>) % MaxSize;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取队头元素，但该元素并没有出队列而是依旧在队列中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序队列为空，不能读取队头元素!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e = m_data[m_front];  <span class="comment">//队头元素返回到e中。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出顺序队列中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqQueue&lt;T&gt;::<span class="built_in">DispQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//按照从对头到队尾的顺序来显示数据</span></span><br><span class="line"><span class="comment">//for (int i = m_front; i &lt; m_rear ; ++i)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = m_front; i != m_rear;)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">i = (i + <span class="number">1</span>) % MaxSize;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取顺序队列的长度（实际拥有的元素数量），时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> SeqQueue&lt;T&gt;::<span class="built_in">QueueLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//return m_rear - m_front;</span></span><br><span class="line"><span class="keyword">return</span> (m_rear + MaxSize - m_front) % MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断顺序队列是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_front == m_rear)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断顺序队列是否已满，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if(m_rear &gt;= MaxSize) //队尾指针和数组容量做比较</span></span><br><span class="line"><span class="keyword">if</span> ((m_rear + <span class="number">1</span>) % MaxSize == m_front)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将队列清空 记住这个特性</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqQueue&lt;T&gt;::<span class="built_in">ClearQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_front = m_rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);<span class="comment">//程序退出时检测内存泄漏并显示到“输出”窗口</span></span><br><span class="line"></span><br><span class="line">_nmsp1::SeqQueue&lt;<span class="type">int</span>&gt; seqobj;</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">150</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">200</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">300</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">400</span>);</span><br><span class="line">seqobj.<span class="built_in">DispQueue</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">seqobj.<span class="built_in">DeQueue</span>(eval);</span><br><span class="line">seqobj.<span class="built_in">DeQueue</span>(eval);</span><br><span class="line">seqobj.<span class="built_in">DispQueue</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------&quot;</span> &lt;&lt; endl;</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">500</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">600</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">700</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">800</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">900</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">1000</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">1100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//seqobj.EnQueue(1200);</span></span><br><span class="line">seqobj.<span class="built_in">DispQueue</span>();</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">1100</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">1100</span>);</span><br><span class="line">seqobj.<span class="built_in">EnQueue</span>(<span class="number">1100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="引入一个变量标记"><a href="#引入一个变量标记" class="headerlink" title="引入一个变量标记"></a>引入一个变量标记</h3><ul><li><p>引入一个char类型的成员变量m_tag,初始值为0，当执行出队列操作时，把该变量的设置为0，当执行入队列操作时，把该变量的值设置为1，这样就可以显示最近执行的时删除操作和插入操作</p></li><li><p>只有出队列操作才会导致队列为空，只有入队列才会导致队列变满</p><p>入队操作的编程实现</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">EnQueue</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsFull == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;该队列已满&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m_tag = <span class="number">1</span>;</span><br><span class="line">    m_data[m_rear] = e;</span><br><span class="line"><span class="comment">//m_rear++;</span></span><br><span class="line">m_rear = (m_rear + <span class="number">1</span>) % MaxSize; <span class="comment">//队尾指针加1并取余，这样m_data的下标就控制在了0到(MaxSize-1)之间了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否已满操作</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断顺序队列是否已满，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_front == m_rear &amp;&amp; m_tag == <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队列操作</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">DeQueue</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;该队列是空的&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">        m_tag = <span class="number">0</span>;  <span class="comment">//出队标记</span></span><br><span class="line">e = m_data[m_front];</span><br><span class="line">m_front = (m_front + <span class="number">1</span>) % MaxSize;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否为空操作</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断顺序队列是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_front == m_rear&amp;&amp; m_tag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h1><ul><li>所谓的链式队列，就是一个操作受限的单链表，只允许在尾部插入元素（队尾），在头部删除元素（对头）。</li><li>一定要及时更新队尾指针</li><li>和单链表几乎一致的代码，不一一说明</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QueueNode</span></span><br><span class="line">&#123;</span><br><span class="line">T data;</span><br><span class="line">QueueNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LinkQueue</span>();</span><br><span class="line">~<span class="built_in">LinkQueue</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(<span class="type">const</span> T&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(T&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispQueue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">QueueNode&lt;T&gt;* m_front;</span><br><span class="line">QueueNode&lt;T&gt;* m_rear;</span><br><span class="line"><span class="type">int</span> m_length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkQueue&lt;T&gt;::<span class="built_in">LinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_front = <span class="keyword">new</span> QueueNode&lt;T&gt;;</span><br><span class="line">m_front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">m_rear = m_front;</span><br><span class="line">m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkQueue&lt;T&gt;::~<span class="built_in">LinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">QueueNode&lt;T&gt;* pnode = m_front-&gt;next;<span class="comment">//首先删除的头结点之后的第一个元素</span></span><br><span class="line">QueueNode&lt;T&gt;* ptmp;</span><br><span class="line"><span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">ptmp = pnode;</span><br><span class="line">pnode = pnode-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> ptmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> m_front;<span class="comment">//删除头结点</span></span><br><span class="line">m_front = m_rear = <span class="literal">nullptr</span>;</span><br><span class="line">m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队列操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">EnQueue</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">QueueNode&lt;T&gt;* node = <span class="keyword">new</span> QueueNode&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//只能在队尾插入</span></span><br><span class="line">m_rear-&gt;next = node;</span><br><span class="line">m_rear = node;<span class="comment">//更新尾指针</span></span><br><span class="line">m_length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">DeQueue</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;该队列为空&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QueueNode&lt;T&gt;* p_willdel = m_front-&gt;next;<span class="comment">//出的是头结点之后第一个元素，不是头结点</span></span><br><span class="line">e = p_willdel-&gt;data;</span><br><span class="line">m_front-&gt;next = p_willdel-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (m_rear == p_willdel)</span><br><span class="line">&#123;</span><br><span class="line">m_rear = m_front;<span class="comment">//当队列只有一个头结点和一个元素结点，删除后就更新尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> p_willdel;</span><br><span class="line">m_length--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取队头元素，但该元素并没有出队列而是依旧在队列中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前链式队列为空，不能读取队头元素!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e = m_front-&gt;next-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出链式队列中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkQueue&lt;T&gt;::<span class="built_in">DispQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">QueueNode&lt;T&gt;* p = m_front-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取链式队列的长度（实际拥有的元素数量），时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> LinkQueue&lt;T&gt;::<span class="built_in">QueueLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链式队列是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_front == m_rear) <span class="comment">//当然，换一种判断方式也行：if(m_front-&gt;next == nullptr) return true;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);<span class="comment">//程序退出时检测内存泄漏并显示到“输出”窗口</span></span><br><span class="line"></span><br><span class="line">_nmsp1::LinkQueue&lt;<span class="type">int</span>&gt; lnobj;</span><br><span class="line">lnobj.<span class="built_in">EnQueue</span>(<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">lnobj.<span class="built_in">DeQueue</span>(eval);</span><br><span class="line">lnobj.<span class="built_in">EnQueue</span>(<span class="number">200</span>);</span><br><span class="line">lnobj.<span class="built_in">EnQueue</span>(<span class="number">700</span>);</span><br><span class="line">lnobj.<span class="built_in">DispQueue</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线性表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序栈和链式栈的实现（c++）</title>
      <link href="/archives/57e1df2e.html"/>
      <url>/archives/57e1df2e.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h1><ul><li>栈是线性表的一种，其特点是只能在一端进行插入和删除操作，因此具有先进后出和后进先出的特性。</li><li>把栈形象一点的说明就是把它比作桶这样一种容器。栈有两端，把允许进行插入和删除的一端作为栈顶，也就是桶口，或者是线性表的表尾；而另一端叫做栈底，也就是桶底，或者是表头。</li><li>通俗直接一点就是一个人为规定的受限的线性表。我们只能在栈顶进行入栈和出栈操作。</li><li>在STL标准库中，提供了一个名字为stack的容器，是一个类模板，实现了站的功能.</li><li>栈有两种存储方式，一种为顺序存储的栈，另一种为链式存储的栈。</li></ul><h1 id="栈的顺序存储"><a href="#栈的顺序存储" class="headerlink" title="栈的顺序存储"></a>栈的顺序存储</h1><ul><li>顺序栈和顺序表是类似的，在入栈和出栈操作只支持栈顶的位置进行操作。</li></ul><h2 id="顺序栈的编程实现"><a href="#顺序栈的编程实现" class="headerlink" title="顺序栈的编程实现"></a>顺序栈的编程实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10   <span class="comment">//动态数组的初始尺寸</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IncSize  5    <span class="comment">//当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//T代表数组中元素的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SeqStack</span>(<span class="type">int</span> length = InitSize);     <span class="comment">//构造函数，参数可以有默认值</span></span><br><span class="line">~<span class="built_in">SeqStack</span>();                         <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;               <span class="comment">//入栈（增加数据）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(T&amp; e)</span></span>;                      <span class="comment">//出栈（删除数据），也就是删除栈顶数据</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(T&amp; e)</span></span>;                   <span class="comment">//读取栈顶元素，但该元素并没有出栈而是依旧在栈中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;                     <span class="comment">//输出顺序栈中的所有元素</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">ListLength</span><span class="params">()</span></span>;                   <span class="comment">//获取顺序栈的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">()</span></span>;                 <span class="comment">//当顺序栈存满数据后可以调用此函数为顺序栈扩容</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;                      <span class="comment">//判断顺序栈是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;                       <span class="comment">//判断顺序栈是否已满</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_data;                          <span class="comment">//存放顺序栈中的元素</span></span><br><span class="line"><span class="type">int</span> m_maxsize;                       <span class="comment">//动态数组最大容量</span></span><br><span class="line"><span class="type">int</span> m_top;                           <span class="comment">//栈顶指针(用作数组下标)，指向栈顶元素，该值为-1表示空栈</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数对顺序栈进行初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqStack&lt;T&gt;::<span class="built_in">SeqStack</span>(<span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">m_data = <span class="keyword">new</span> T[length];  <span class="comment">//为一维数组动态分配内存</span></span><br><span class="line">m_maxsize = length;      <span class="comment">//顺序栈最多可以存储m_maxsize个数据元素</span></span><br><span class="line">m_top = <span class="number">-1</span>;              <span class="comment">//空栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对顺序栈进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqStack&lt;T&gt;::~<span class="built_in">SeqStack</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈（增加数据）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;顺序栈已满，不能再进行入栈操作了!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="built_in">IncreaseSize</span>(); <span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_top++;           <span class="comment">//栈顶指针向后走</span></span><br><span class="line">m_data[m_top] = e; <span class="comment">//本行和上一行可以合并写成一行代码：m_data[++m_top] = e;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当顺序栈存满数据后可以调用此函数为顺序栈扩容，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqStack&lt;T&gt;::<span class="built_in">IncreaseSize</span>()</span><br><span class="line">&#123;</span><br><span class="line">T* p = m_data;</span><br><span class="line">m_data = <span class="keyword">new</span> T[m_maxsize + IncSize]; <span class="comment">//重新为顺序栈分配更大的内存空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m_top; i++)</span><br><span class="line">&#123;</span><br><span class="line">m_data[i] = p[i];                <span class="comment">//将数据复制到新区域</span></span><br><span class="line">&#125;</span><br><span class="line">m_maxsize = m_maxsize + IncSize;     <span class="comment">//顺序栈最大长度增加IncSize</span></span><br><span class="line"><span class="keyword">delete</span>[] p;                          <span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈（删除数据），也就是删除栈顶数据</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">Pop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序栈为空，不能进行出栈操作!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e = m_data[m_top];  <span class="comment">//栈顶元素值返回到e中。</span></span><br><span class="line">m_top--;           </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素，但该元素并没有出栈而是依旧在栈顶中，因此m_top值不会发生改变</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">GetTop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序栈为空，不能读取栈顶元素!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e = m_data[m_top];  <span class="comment">//栈顶元素返回到e中。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出顺序栈中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqStack&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//按照从栈顶到栈底的顺序来显示数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = m_top; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取顺序栈的长度（实际拥有的元素数量），时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> SeqStack&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_top + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断顺序栈是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_top == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断顺序栈是否已满，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_top &gt;= m_maxsize - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line"></span><br><span class="line"><span class="function">_nmsp1::SeqStack&lt;<span class="type">int</span>&gt; <span class="title">seqobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">seqobj.<span class="built_in">Push</span>(<span class="number">150</span>);</span><br><span class="line">seqobj.<span class="built_in">Push</span>(<span class="number">200</span>);</span><br><span class="line">seqobj.<span class="built_in">Push</span>(<span class="number">300</span>);</span><br><span class="line">seqobj.<span class="built_in">Push</span>(<span class="number">400</span>);</span><br><span class="line">seqobj.<span class="built_in">DispList</span>();</span><br><span class="line"><span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">seqobj.<span class="built_in">Pop</span>(eval);</span><br><span class="line">seqobj.<span class="built_in">Pop</span>(eval);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------&quot;</span> &lt;&lt; endl;</span><br><span class="line">seqobj.<span class="built_in">DispList</span>();</span><br><span class="line">seqobj.<span class="built_in">Push</span>(<span class="number">8100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><ul><li>根据以上顺序栈的实现来看，顺序栈一个比较大的缺点是保存数据的空间初始尺寸不好确定，太大造成浪费，太小造成频繁扩容操作，消耗性能；</li><li>共享栈的含义：开辟一块保存数据的空间，让这两个栈同时使用这一块空间，也许能达到最大限度地利用这块空间，减少浪费的目的。</li><li>共享栈的入栈和出栈的如图所示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chuannihaoa/picog/imageimage-20221126205746284.png" alt="共享栈"></p><ul><li>代码实现只写出了与顺序栈的不一样的地方</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//共享栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//T代表数组中元素的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ShareStack</span>(<span class="type">int</span> length = InitSize)    <span class="comment">//构造函数，参数可以有默认值</span></span><br><span class="line">&#123;</span><br><span class="line">m_data = <span class="keyword">new</span> T[length];  <span class="comment">//为一维数组动态分配内存</span></span><br><span class="line">m_maxsize = length;      <span class="comment">//顺序栈最多可以存储m_maxsize个数据元素</span></span><br><span class="line">m_top1 = <span class="number">-1</span>;             <span class="comment">//顺序栈1的栈顶指针为-1，表示空栈</span></span><br><span class="line">m_top2 = length;         <span class="comment">//顺序栈2的栈顶指针为length，表示空栈</span></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">ShareStack</span>()                        <span class="comment">//析构函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span>                        <span class="comment">//判断共享栈是否已满</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_top1 + <span class="number">1</span> == m_top2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> stackNum, <span class="type">const</span> T&amp; e)</span>      <span class="comment">//入栈（增加数据）,参数stackNum用//于标识栈1还是栈2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//共享栈满了，读者也可以自行增加代码来支持动态增加共享栈的容量，这里简单处//理，直接返回false</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;共享栈已满，不能再进行入栈操作了!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (stackNum == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//要入的是顺序栈1</span></span><br><span class="line">m_top1++;           <span class="comment">//栈顶指针向后走</span></span><br><span class="line">m_data[m_top1] = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//要入的是顺序栈2</span></span><br><span class="line">m_top2--;</span><br><span class="line">m_data[m_top2] = e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(<span class="type">int</span> stackNum, T&amp; e)</span>          <span class="comment">//出栈（删除数据），也就是删除栈顶数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (stackNum == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//要从顺序栈1出栈</span></span><br><span class="line"><span class="keyword">if</span> (m_top1 == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序栈1为空，不能进行出栈操作!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = m_data[m_top1];  <span class="comment">//栈顶元素值返回到e中</span></span><br><span class="line">m_top1--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//要从顺序栈2出栈</span></span><br><span class="line"><span class="keyword">if</span> (m_top2 == m_maxsize)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序栈2为空，不能进行出栈操作!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = m_data[m_top2];</span><br><span class="line">m_top2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_data;                          <span class="comment">//存放共享栈中的元素</span></span><br><span class="line"><span class="type">int</span> m_maxsize;                       <span class="comment">//动态数组最大容量</span></span><br><span class="line"><span class="type">int</span> m_top1;                          <span class="comment">//顺序栈1的栈顶指针</span></span><br><span class="line"><span class="type">int</span> m_top2;                          <span class="comment">//顺序栈2的栈顶指针    </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="栈的链式存储"><a href="#栈的链式存储" class="headerlink" title="栈的链式存储"></a>栈的链式存储</h1><ul><li>表明含义就是用链式存储方式来实现的栈，顾名思义就是受限的单链表，只不过是人为的规定在单链表的第一个位置进行入栈和出栈操作。</li><li>需要注意的是链表头是栈顶，不要搞混了。因为要考虑到只在链表头位置插入数据，以下的编程实现没有头结点。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StackNode</span></span><br><span class="line">&#123;</span><br><span class="line">T data;</span><br><span class="line">StackNode&lt;T&gt;* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">LinkStack</span>();</span><br><span class="line">~<span class="built_in">LinkStack</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(T&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(T&amp; e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">StackNode&lt;T&gt;* m_top;</span><br><span class="line"><span class="type">int</span>  m_length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkStack&lt;T&gt;::<span class="built_in">LinkStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_top = <span class="literal">nullptr</span>;</span><br><span class="line">m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">StackNode&lt;T&gt;* node = <span class="keyword">new</span> StackNode&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = m_top;</span><br><span class="line">m_top = node;</span><br><span class="line">m_length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Pop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">StackNode&lt;T&gt;* p_willdel = m_top;  <span class="comment">//和单链表是一样的操作</span></span><br><span class="line">m_top = m_top-&gt;next;</span><br><span class="line">m_length--;</span><br><span class="line">e = p_willdel-&gt;data;</span><br><span class="line"><span class="keyword">delete</span> p_willdel;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">GetTop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">e = m_top-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkStack&lt;T&gt;::<span class="built_in">DisList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StackNode&lt;T&gt;* p = m_top;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> LinkStack&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链式栈是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_top == <span class="literal">nullptr</span>) <span class="comment">//链式栈为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对链式栈进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkStack&lt;T&gt;::~<span class="built_in">LinkStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">T tmpnousevalue = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">Pop</span>(tmpnousevalue) == <span class="literal">true</span>) &#123;&#125;<span class="comment">//Pop具有删除的元素的能力，真正退出//while循环的是Empty（）得到的false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line"></span><br><span class="line">_nmsp1::LinkStack&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">slinkobj.<span class="built_in">Push</span>(<span class="number">12</span>);</span><br><span class="line">slinkobj.<span class="built_in">Push</span>(<span class="number">24</span>);</span><br><span class="line">slinkobj.<span class="built_in">Push</span>(<span class="number">48</span>);</span><br><span class="line">slinkobj.<span class="built_in">Push</span>(<span class="number">100</span>);</span><br><span class="line">slinkobj.<span class="built_in">DisList</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">slinkobj.<span class="built_in">Pop</span>(eval);</span><br><span class="line">slinkobj.<span class="built_in">DisList</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="两者的对比"><a href="#两者的对比" class="headerlink" title="两者的对比"></a>两者的对比</h1><ul><li>与顺序栈相比，链式栈式没有长度限制，不存在浪费空间的问题</li><li>对于入栈和出栈这些需要对数据进行定位的操作，顺序栈更加方便</li><li>链式栈需要额外的指针域来指向下一个数据结点，会略微降低数据的存储效率</li><li>如果数据无法提前预估，一般考虑链式栈，知道数量固定，考虑使用顺序栈</li></ul><hr><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ol><li>保存临时数据</li><li>计算机表达式结果</li></ol><h2 id="利用栈进行括号的检验"><a href="#利用栈进行括号的检验" class="headerlink" title="利用栈进行括号的检验"></a>利用栈进行括号的检验</h2><ul><li>需求说明：利用栈来检查一个表达式中括号数量是否匹配。（）[]  {}假设这三种括号，目的就是给出一个含有三种括号的表达式，来检查这个表达式的合法性。</li><li>思路：<ul><li>从左侧开始扫描表达式，遇到（  [  { 这三种左括号之一将其入栈。</li><li>当遇到  )   ]  }  之一时，就从栈顶取出一个括号进行尝试匹配。</li><li>如果匹配成功，则继续扫描表达式剩余的字符串，如果匹配失败，或者栈顶取出的数据失败都判定为表达式不正确。</li><li>当表达式子的所有括号扫描完毕并且括号匹配之后，还要确定栈是否为空，栈为空，则说明表达式格式合法，否则为非法。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;boost/type_index.hpp&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#pragma warning(disable : 4996) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//链式栈中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StackNode</span></span><br><span class="line">&#123;</span><br><span class="line">T        data;  <span class="comment">//数据域，存放数据元素</span></span><br><span class="line">StackNode&lt;T&gt;* next;  <span class="comment">//指针域，指向下一个同类型（和本节点类型相同）节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式栈的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LinkStack</span>();      <span class="comment">//构造函数，参数可以有默认值</span></span><br><span class="line">~<span class="built_in">LinkStack</span>();     <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>; <span class="comment">//入栈元素e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(T&amp; e)</span></span>;        <span class="comment">//出栈（删除数据），也就是删除栈顶数据</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(T&amp; e)</span></span>;     <span class="comment">//读取栈顶元素，但该元素并没有出栈而是依旧在栈中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;                     <span class="comment">//输出链式栈中的所有元素</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">ListLength</span><span class="params">()</span></span>;                   <span class="comment">//获取链式栈的长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;                        <span class="comment">//判断链式栈是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">StackNode&lt;T&gt;*     m_top;   <span class="comment">//栈顶指针</span></span><br><span class="line"><span class="type">int</span>               m_length;<span class="comment">//链式栈当前长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数对链式栈进行初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkStack&lt;T&gt;::<span class="built_in">LinkStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_top = <span class="literal">nullptr</span>;</span><br><span class="line">m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈元素e，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">StackNode&lt;T&gt;* node = <span class="keyword">new</span> StackNode&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = m_top;</span><br><span class="line">m_top = node;</span><br><span class="line">m_length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈（删除数据），也就是删除栈顶数据，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Pop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>) <span class="comment">//链式栈为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">StackNode&lt;T&gt;* p_willdel = m_top;</span><br><span class="line">m_top = m_top-&gt;next;</span><br><span class="line">m_length--;</span><br><span class="line">e = p_willdel-&gt;data;</span><br><span class="line"><span class="keyword">delete</span> p_willdel;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素，但该元素并没有出栈而是依旧在栈中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">GetTop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>) <span class="comment">//链式栈为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">e = m_top-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出链式栈中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkStack&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>) <span class="comment">//链式栈为空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">StackNode&lt;T&gt;* p = m_top;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取链式栈的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span>  LinkStack&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链式栈是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_top == <span class="literal">nullptr</span>) <span class="comment">//链式栈为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对链式栈进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkStack&lt;T&gt;::~<span class="built_in">LinkStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">T tmpnousevalue = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">Pop</span>(tmpnousevalue) == <span class="literal">true</span>) &#123;&#125;<span class="comment">//把栈顶元素删光，实际上式通过empty来决//定是否退出循环，此时也就是空栈了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> ifMatchSucc = <span class="literal">true</span>;  <span class="comment">//是否匹配成功的标志，先标记未匹配成功</span></span><br><span class="line">_nmsp1::LinkStack&lt;<span class="type">char</span>&gt; slinkobjprocKH;  <span class="comment">//保存左括号的栈</span></span><br><span class="line">string strExp = <span class="string">&quot;[(&#123;&#125;)&#123;&#125;]&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; strExp.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (strExp[i] ==  <span class="string">&#x27;(&#x27;</span> ||  strExp[i]  == <span class="string">&#x27;[&#x27;</span> || strExp[i] == <span class="string">&#x27;&#123;&#x27;</span>) <span class="comment">//左括//号全部入栈</span></span><br><span class="line">&#123;</span><br><span class="line">slinkobjprocKH.<span class="built_in">Push</span>(strExp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当前是一个右括号，则从栈顶取出一个左括号</span></span><br><span class="line"><span class="type">char</span> tmptopchar;</span><br><span class="line"><span class="keyword">if</span> (slinkobjprocKH.<span class="built_in">Pop</span>(tmptopchar) == <span class="literal">false</span>) <span class="comment">//从栈顶取出数据失败</span></span><br><span class="line">&#123;</span><br><span class="line">ifMatchSucc = <span class="literal">false</span>; <span class="comment">//匹配失败标记</span></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//跳出for循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得了栈顶的一个左括号，看一看是否匹配</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">(strExp[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; tmptopchar == <span class="string">&#x27;(&#x27;</span>) ||</span><br><span class="line">(strExp[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; tmptopchar == <span class="string">&#x27;[&#x27;</span>) ||</span><br><span class="line">(strExp[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; tmptopchar == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">//继续扫描</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//括号不匹配</span></span><br><span class="line">ifMatchSucc = <span class="literal">false</span>; <span class="comment">//匹配失败标记</span></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//跳出for循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">// end for</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//扫描完成后，还要确定slinkobjprocKH为空才可以</span></span><br><span class="line"><span class="keyword">if</span> (ifMatchSucc == <span class="literal">true</span> &amp;&amp; slinkobjprocKH.<span class="built_in">Empty</span>()==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">ifMatchSucc = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ifMatchSucc == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; strExp &lt;&lt; <span class="string">&quot;\&quot;格式合法，括号配对数量和顺序都正确&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; strExp &lt;&lt; <span class="string">&quot;\&quot;格式非法，括号配对数量或顺序不正确&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线性表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双循环链表的实现（c++）</title>
      <link href="/archives/1d2d9f6e.html"/>
      <url>/archives/1d2d9f6e.html</url>
      
        <content type="html"><![CDATA[<h1 id="双循环链表"><a href="#双循环链表" class="headerlink" title="双循环链表"></a>双循环链表</h1><ul><li><p>在双链表的基础上，将链表中的最后一个结点的后继指针由指向nullptr修改为指向头结点，将链表头结点的前趋指针由指向nullptr修改为指向最后一个结点，从而构成双循环链表。</p></li><li><p>与双链表的主要的改动是</p><ul><li>在于构造函数的头结点的next指针和prior指针初始化时指向自己。</li><li>判断是否为空应该是m_head-&gt;next &#x3D;&#x3D; m_head而不是m_head-&gt;next&#x3D;&#x3D; nullptr.</li><li>最关键的是插入和删除操作，要注意维护好最后一个结点的后继指针指向，保证其永远指向头结点，也要注意头结点的前趋指针的指向，保证其永远指向最后一个结点。除了头部和尾部的插入和删除操作，与双链表的的操作是一致的。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Double_Node</span></span><br><span class="line">&#123;</span><br><span class="line">T data;<span class="comment">//数据域</span></span><br><span class="line">Double_Node&lt;T&gt;* prior;<span class="comment">//前趋指针</span></span><br><span class="line">Double_Node &lt;T&gt;* next;<span class="comment">//后继指针</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Db_Cir_Link_List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Db_Cir_Link_List</span>();</span><br><span class="line">~<span class="built_in">Db_Cir_Link_List</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">//在第i个位置插入指定元素e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;              <span class="comment">//删除第i个位置的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;           <span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;         <span class="comment">//按元素值查找其在双循环链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;                     <span class="comment">//输出双循环链表中的所有元素</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">ListLength</span><span class="params">()</span></span>;                   <span class="comment">//获取双循环链表的长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;                        <span class="comment">//判断双循环链表是否为空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Double_Node&lt;T&gt;* m_head;</span><br><span class="line"><span class="type">int</span> m_length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Db_Cir_Link_List&lt;T&gt;::<span class="built_in">Db_Cir_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_head = <span class="keyword">new</span> Double_Node&lt;T&gt;;</span><br><span class="line">m_head-&gt;next = m_head;</span><br><span class="line">m_head-&gt;prior = m_head;</span><br><span class="line">m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Db_Cir_Link_List&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断插入位置i是否合法，i的合法值应该是1到length+1之间</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;*node = <span class="keyword">new</span> Double_Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = p_curr-&gt;next;</span><br><span class="line">node-&gt;prior = p_curr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为是循环的，就不需要进行if(p_curr-&gt;next != m_head)</span></span><br><span class="line">p_curr-&gt;next-&gt;prior = node;</span><br><span class="line">p_curr-&gt;next = node;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;        <span class="comment">//实际表长+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Db_Cir_Link_List&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前双循环链表为空，不能删除任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_willdel = p_curr-&gt;next; <span class="comment">//p_willdel指向待删除的节点</span></span><br><span class="line">Double_Node&lt;T&gt;* p_willdelNext = p_willdel-&gt;next; <span class="comment">//p_willdelNext指向待删除节点的下一个节点</span></span><br><span class="line">p_curr-&gt;next = p_willdel-&gt;next;<span class="comment">//第i-1个节点的next指针指向第i+1个节点</span></span><br><span class="line"><span class="comment">// 链表是循环的不需要进行  if (p_willdelNext != m_head)</span></span><br><span class="line">p_willdelNext-&gt;prior = p_curr;<span class="comment">//第i+1个节点的prior指针指向第i-1个节点</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length--;<span class="comment">//实际表长-1</span></span><br><span class="line"><span class="keyword">delete</span> p_willdel;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Db_Cir_Link_List&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前双循环链表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">e = p_curr-&gt;data;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按元素值查找其在双循环链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Db_Cir_Link_List&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双循环链表中第一次出现的位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双循环链表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出双循环链表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Db_Cir_Link_List&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* p = m_head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != m_head) <span class="comment">//这里采用while循环或者for循环书写都可以</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取双循环链表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span>  Db_Cir_Link_List&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双循环链表是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Db_Cir_Link_List&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_head-&gt;next == m_head) <span class="comment">//双循环链表为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对双循环链表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Db_Cir_Link_List&lt;T&gt;::~<span class="built_in">Db_Cir_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">Double_Node&lt;T&gt;* ptmp;</span><br><span class="line"><span class="keyword">while</span> (pnode != m_head) <span class="comment">//该循环负责释放数据节点</span></span><br><span class="line">&#123;</span><br><span class="line">ptmp = pnode;</span><br><span class="line">pnode = pnode-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> ptmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> m_head;    <span class="comment">//释放头结点</span></span><br><span class="line">m_head = <span class="literal">nullptr</span>; <span class="comment">//非必须</span></span><br><span class="line">m_length = <span class="number">0</span>;     <span class="comment">//非必须</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line"></span><br><span class="line">_nmsp1::Db_Cir_Link_List&lt;<span class="type">int</span>&gt;slinkobj;</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">slinkobj.<span class="built_in">ListDelete</span>(<span class="number">3</span>);</span><br><span class="line">slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">slinkobj.<span class="built_in">GetElem</span>(<span class="number">3</span>,a);</span><br><span class="line">cout &lt;&lt; slinkobj.<span class="built_in">ListLength</span>() &lt;&lt; endl;</span><br><span class="line">slinkobj.<span class="built_in">Empty</span>();</span><br><span class="line">slinkobj.<span class="built_in">LocateElem</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线性表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单循环链表的实现（c++）</title>
      <link href="/archives/b24eb132.html"/>
      <url>/archives/b24eb132.html</url>
      
        <content type="html"><![CDATA[<h1 id="单循环列表"><a href="#单循环列表" class="headerlink" title="单循环列表"></a>单循环列表</h1><ul><li>在单链表的基础上，将链表的最后一个结点的后继指针由指向nullptr修改为指向头结点。</li><li>优势在于只要给定了任意一个结点，都可以访问链表的所有结点</li><li>需要注意的是判断条件是头结点而不是nullptr</li></ul><h2 id="单循环列表的编程实现"><a href="#单循环列表的编程实现" class="headerlink" title="单循环列表的编程实现"></a>单循环列表的编程实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">T        data;  <span class="comment">//数据域，存放数据元素</span></span><br><span class="line">Node&lt;T&gt;* next;  <span class="comment">//指针域，指向下一个同类型（和本节点类型相同）节点</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单循环链表的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CirLinkList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CirLinkList</span>();      <span class="comment">//构造函数，参数可以有默认值</span></span><br><span class="line">~<span class="built_in">CirLinkList</span>();     <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">//在第i个位置插入指定元素e</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListInsertBack</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;              <span class="comment">//删除第i个位置的元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;           <span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;         <span class="comment">//按元素值查找其在单循环链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;                     <span class="comment">//输出单循环链表中的所有元素</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">ListLength</span><span class="params">()</span></span>;                   <span class="comment">//获取单循环链表的长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;                        <span class="comment">//判断单循环链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rear</span><span class="params">()</span></span>; <span class="comment">//检验尾指针的指向是否正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge_Link_list</span><span class="params">(CirLinkList&lt;T&gt; p1, CirLinkList&lt;T&gt; p2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;T&gt;* m_head;<span class="comment">//头指针</span></span><br><span class="line">Node&lt;T&gt;* m_rear;<span class="comment">//尾指针</span></span><br><span class="line"><span class="type">int</span> m_length;<span class="comment">//单循环链表长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数对单循环链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CirLinkList&lt;T&gt;::<span class="built_in">CirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_head = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">//先创建一个头结点</span></span><br><span class="line">m_head-&gt;next = m_head;<span class="comment">//指向头部（注意和单链表的差别）</span></span><br><span class="line">m_rear = m_head;<span class="comment">//尾指针初始化和头结点是一样的</span></span><br><span class="line">m_length = <span class="number">0</span>;<span class="comment">//头结点不计入单循环链表的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置（位置编号从1开始）插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断插入位置i是否合法，i的合法值应该是1到length+1之间</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是要插入尾指针之后</span></span><br><span class="line"><span class="comment">//如果i= 表长+1 ：代表就插入在尾处，相当于单链表的尾插法</span></span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">1</span> == m_length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ListInsertBack</span>(e);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = p_curr-&gt;next;</span><br><span class="line">p_curr-&gt;next = node;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;        <span class="comment">//实际表长+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速在尾部插入元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CirLinkList&lt;T&gt;::<span class="built_in">ListInsertBack</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = m_rear-&gt;next;</span><br><span class="line">m_rear-&gt;next = node;</span><br><span class="line">m_rear = node;</span><br><span class="line"><span class="keyword">if</span> (m_rear-&gt;next == m_head)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;尾部插入元素成功，更新尾指针成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">m_length++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前单循环链表为空，不能删除任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)<span class="comment">//用于定位</span></span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;T&gt;* p_willdel = p_curr-&gt;next;<span class="comment">//p_willdel指向待删除的节点</span></span><br><span class="line">p_curr-&gt;next = p_willdel-&gt;next;<span class="comment">//第i-1个节点的next指针指向第i+1个节点</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length--;<span class="comment">//实际表长-1</span></span><br><span class="line"><span class="keyword">delete</span> p_willdel;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前单循环链表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">e = p_curr-&gt;data;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按元素值查找其在单循环链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> CirLinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单循环链表中第一次出现的位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单循环链表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出单循环链表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> CirLinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* p = m_head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != m_head)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单循环链表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span>  CirLinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对单循环链表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CirLinkList&lt;T&gt;::~<span class="built_in">CirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">Node&lt;T&gt;* ptmp;</span><br><span class="line"><span class="keyword">while</span> (pnode != m_head)   <span class="comment">//该循环负责释放数据节点（注意循环的条件）</span></span><br><span class="line">&#123;</span><br><span class="line">ptmp = pnode;</span><br><span class="line"></span><br><span class="line">pnode = pnode-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> ptmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> m_head;    <span class="comment">//释放头结点</span></span><br><span class="line">m_head = <span class="literal">nullptr</span>;<span class="comment">//非必须</span></span><br><span class="line">m_length = <span class="number">0</span>;     <span class="comment">//非必须</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CirLinkList&lt;T&gt;::<span class="built_in">rear</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; 链表最后一个元素为&quot;</span> &lt;&lt; m_rear-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CirLinkList&lt;T&gt;::<span class="built_in">Merge_Link_list</span>(CirLinkList&lt;T&gt;p1, CirLinkList&lt;T&gt;p2)<span class="comment">//合并两个单循环链表</span></span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* p1_rear = p1.m_rear;</span><br><span class="line">Node&lt;T&gt;* p1head = p1_rear-&gt;next;</span><br><span class="line">Node&lt;T&gt;* p2_rear = p2.m_rear;</span><br><span class="line">Node&lt;T&gt;* p2head = p2_rear-&gt;next;</span><br><span class="line"></span><br><span class="line">p1_rear-&gt;next = p2_rear-&gt;next-&gt;next;</span><br><span class="line">p2_rear-&gt;next = p1head;</span><br><span class="line"></span><br><span class="line">p1_rear = p2_rear;</span><br><span class="line"><span class="comment">//delete p2head;</span></span><br><span class="line">p1.m_length += p2.m_length;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;合并链表&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);<span class="comment">//程序退出时检测内存泄漏并显示到“输出”窗口</span></span><br><span class="line"></span><br><span class="line">_nmsp1::CirLinkList&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">_nmsp1::CirLinkList&lt;<span class="type">int</span>&gt; slinkobj1;</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">slinkobj.<span class="built_in">rear</span>();</span><br><span class="line"></span><br><span class="line">slinkobj1.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">slinkobj1.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">slinkobj1.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">3000</span>);</span><br><span class="line">slinkobj1.<span class="built_in">ListInsert</span>(<span class="number">4</span>, <span class="number">4000</span>);</span><br><span class="line">slinkobj1.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">slinkobj.<span class="built_in">Merge_Link_list</span>(slinkobj, slinkobj1);</span><br><span class="line">slinkobj1.<span class="built_in">DispList</span>();</span><br><span class="line">slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//slinkobj.ListInsertBack(1000);</span></span><br><span class="line"><span class="comment">//slinkobj.DispList();</span></span><br><span class="line"><span class="comment">//slinkobj.rear();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//slinkobj.ListDelete(4);</span></span><br><span class="line"><span class="comment">//slinkobj.rear();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int eval = 0;</span></span><br><span class="line"><span class="comment">//slinkobj.GetElem(3, eval); //如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line"><span class="comment">//int findvalue = 100; //在单循环链表中要找的元素值</span></span><br><span class="line"><span class="comment">//slinkobj.LocateElem(findvalue);</span></span><br><span class="line"><span class="comment">//slinkobj.DispList();</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;单循环链表的长度为：&quot; &lt;&lt; slinkobj.ListLength() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：以上代码不是完全正确，在合并两个单链表的功能报错，后续解决。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线性表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双链表的实现（c++）</title>
      <link href="/archives/68c04350.html"/>
      <url>/archives/68c04350.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是双链表"><a href="#什么是双链表" class="headerlink" title="什么是双链表"></a>什么是双链表</h1><ul><li>单链表的缺点<ul><li>如果要寻找单链表中某个已知结点的前趋结点会比较繁琐，必须去从链表头出发开始寻找，这样也就导致算法的平均情况时间复杂度O（n）。</li></ul></li><li>在单链表的基础上，增加一个用于指向前趋节点的指针。也就是说双链表是由单链表衍生出来的链表结构。</li><li>双链表的结点中有两个指针prior和next，分别指向前驱结点和后继结点。</li></ul><hr><h1 id="双链表的数据成员"><a href="#双链表的数据成员" class="headerlink" title="双链表的数据成员"></a>双链表的数据成员</h1><ul><li>一个结点包含一个数据域和两个指针域（前趋指针，后继指针）</li><li>前趋指针指向该节点的前一个结点</li><li>后继指针指向该结点的后一个结点（尾结点除外，尾结点的后继指针next为nullptr</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双链表中每个结点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Double_Node</span></span><br><span class="line">&#123;</span><br><span class="line">T data;</span><br><span class="line">Double_Node&lt;T&gt;* prior;</span><br><span class="line">Double_Node&lt;T&gt;* next;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="双链表的基本操作"><a href="#双链表的基本操作" class="headerlink" title="双链表的基本操作"></a>双链表的基本操作</h1><ul><li><p>双链表的类的定义和成员函数方法的设计</p><ul><li>构造函数</li><li>析构函数</li><li>在第i个位置插入结点</li><li>删除第i个位置的元素</li><li>获取第i个位置的元素</li><li>获取值为e的在链表中第一次出现的位置</li><li>遍历输出所有元素</li><li>获取双链表的长度</li><li>判断链表是否为空</li></ul><hr></li></ul><h1 id="双链表的编程实现"><a href="#双链表的编程实现" class="headerlink" title="双链表的编程实现"></a>双链表的编程实现</h1><h2 id="双链表类的定义"><a href="#双链表类的定义" class="headerlink" title="双链表类的定义"></a>双链表类的定义</h2><ul><li>和单链表类似</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双链表的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Double_Link_List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Double_Link_List</span>();<span class="comment">//构造函数</span></span><br><span class="line">~<span class="built_in">Double_Link_List</span>();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Double_Link_List_insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//在第i个位置插入</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Double_Link_List_delete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//删除第i个位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Get_Elem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;<span class="comment">//获取第i个位置的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locate_Elem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//获取值为e的第一个出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display_Double_Link_List</span><span class="params">()</span></span>;<span class="comment">//遍历输出所有元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Double_Link_List_length</span><span class="params">()</span></span>;<span class="comment">//获取双链表的长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;<span class="comment">//判断链表是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Double_Node&lt;T&gt;* m_head;<span class="comment">//头结点</span></span><br><span class="line"><span class="type">int</span> m_length;<span class="comment">//表长</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="构造函数并且进行初始化"><a href="#构造函数并且进行初始化" class="headerlink" title="构造函数并且进行初始化"></a>构造函数并且进行初始化</h2><ul><li>头结点的前趋指针永远为空</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_head = <span class="keyword">new</span> Double_Node&lt;T&gt;;</span><br><span class="line">m_head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">m_head-&gt;prior = <span class="literal">nullptr</span>;<span class="comment">//头结点永远为空</span></span><br><span class="line">m_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="在第i个位置插入结点"><a href="#在第i个位置插入结点" class="headerlink" title="在第i个位置插入结点"></a>在第i个位置插入结点</h2><ul><li>首先判断位置<strong>i</strong>是否合法</li><li>遍历结点找到插入位置i的前一个位置</li><li>进行插入结点顺序如图所示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chuannihaoa/picog/imageimage-20221031154341742.png" alt="插入结点"></p><ul><li>表长更新</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List_insert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断插入位置i是否合法，i的合法值应该是1到length+1之间</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;<span class="comment">//用于找到定位应插入的位置的前一个位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* node = <span class="keyword">new</span> Double_Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = p_curr-&gt;next;</span><br><span class="line">node-&gt;prior = p_curr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果插入的位置是尾结点，就没有后续结点的前趋指针指向新结点，故跳过；</span></span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p_curr-&gt;next-&gt;prior = node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">p_curr-&gt;next = node;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="删除第i个位置的元素"><a href="#删除第i个位置的元素" class="headerlink" title="删除第i个位置的元素"></a>删除第i个位置的元素</h2><ul><li>判断表长是否为空</li><li>判断位置i是否合法</li><li>找到删除结点的前一个结点</li><li>进行删除结点顺序如图所示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chuannihaoa/picog/imageimage-20221031155617849.png"></p><ul><li>更新表长</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List_delete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前双链表为空，不能删除任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* will_delete = p_curr-&gt;next<span class="comment">//记录将要删除的结点</span></span><br><span class="line">Double_Node&lt;T&gt;* will_delete_Next = will_delete-&gt;next;<span class="comment">//记录删除结点的下一个位置</span></span><br><span class="line">p_curr-&gt;next = will_delete-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (will_delete_Next != <span class="literal">nullptr</span>)<span class="comment">//删除结点是尾结点故跳过</span></span><br><span class="line">&#123;</span><br><span class="line">will_delete_Next-&gt;prior = p_curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; will_delete-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length--;       <span class="comment">//实际表长-1</span></span><br><span class="line"><span class="keyword">delete</span> will_delete;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="获得第i个位置的元素值"><a href="#获得第i个位置的元素值" class="headerlink" title="获得第i个位置的元素值"></a>获得第i个位置的元素值</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Get_Elem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前双链表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">e = p_curr-&gt;data;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="按元素值查找其在双链表中第一次出现的位置"><a href="#按元素值查找其在双链表中第一次出现的位置" class="headerlink" title="按元素值查找其在双链表中第一次出现的位置"></a>按元素值查找其在双链表中第一次出现的位置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按元素值查找其在双链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Double_Link_List&lt;T&gt;::<span class="built_in">Locate_Elem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双链表中第一次出现的位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双链表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="获取双链表的长度"><a href="#获取双链表的长度" class="headerlink" title="获取双链表的长度"></a>获取双链表的长度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取双链表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span>  Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List_length</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="判断双链表是否为空"><a href="#判断双链表是否为空" class="headerlink" title="判断双链表是否为空"></a>判断双链表是否为空</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断双链表是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_head-&gt;next == <span class="literal">nullptr</span>) <span class="comment">//双链表为空（如果是不带头结点的双链表则用if(m_head == nullptr）来判断是否为空）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="遍历输出所有元素"><a href="#遍历输出所有元素" class="headerlink" title="遍历输出所有元素"></a>遍历输出所有元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Double_Link_List&lt;T&gt;::<span class="built_in">Display_Double_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* p = m_head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>) <span class="comment">//这里采用while循环或者for循环书写都可以</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过析构函数对双链表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Double_Link_List&lt;T&gt;::~<span class="built_in">Double_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">Double_Node&lt;T&gt;* ptmp;</span><br><span class="line"><span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)<span class="comment">//该循环负责释放数据节点</span></span><br><span class="line">&#123;</span><br><span class="line">ptmp = pnode;</span><br><span class="line">pnode = pnode-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> ptmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> m_head;    <span class="comment">//释放头结点</span></span><br><span class="line">m_head = <span class="literal">nullptr</span>; <span class="comment">//非必须</span></span><br><span class="line">m_length = <span class="number">0</span>;     <span class="comment">//非必须</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>在单链表中，如果已知结点的情况下，寻找后继结点的时间复杂度O(1)，如果想要找前趋结点就必须从链表头开始往后遍历，所以最坏情况时间复杂度O(n)；双链表具有前趋指针，找到已知结点的前面一个结点的时间复杂度为O（1），大大提高了寻找效率；</li><li>双链表的某结点p的前趋结点的后继指针以及后继结点的前趋指针代表的都是p结点本身</li><li>因双链表添加了前趋指针，要额外消耗存储空间。</li></ul><h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _nmsp</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表中每个结点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Double_Node</span></span><br><span class="line">&#123;</span><br><span class="line">T data;</span><br><span class="line">Double_Node&lt;T&gt;* prior;</span><br><span class="line">Double_Node&lt;T&gt;* next;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Double_Link_List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Double_Link_List</span>();<span class="comment">//构造函数</span></span><br><span class="line">~<span class="built_in">Double_Link_List</span>();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Double_Link_List_insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//在第i个位置插入</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Double_Link_List_delete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//删除第i个位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Get_Elem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;<span class="comment">//获取第i个位置的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locate_Elem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//获取值为e的第一个出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display_Double_Link_List</span><span class="params">()</span></span>;<span class="comment">//遍历输出所有元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Double_Link_List_length</span><span class="params">()</span></span>;<span class="comment">//获取双链表的长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;<span class="comment">//判断链表是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Double_Node&lt;T&gt;* m_head;</span><br><span class="line"><span class="type">int</span> m_length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_head = <span class="keyword">new</span> Double_Node&lt;T&gt;;</span><br><span class="line">m_head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">m_head-&gt;prior = <span class="literal">nullptr</span>;</span><br><span class="line">m_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List_insert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断插入位置i是否合法，i的合法值应该是1到length+1之间</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;<span class="comment">//用于找到定位应插入的位置的前一个位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* node = <span class="keyword">new</span> Double_Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = p_curr-&gt;next;</span><br><span class="line">node-&gt;prior = p_curr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果插入的位置是尾结点，就没有后续结点的前趋指针指向新结点，故跳过；</span></span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p_curr-&gt;next-&gt;prior = node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">p_curr-&gt;next = node;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List_delete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前双链表为空，不能删除任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* will_delete = p_curr-&gt;next<span class="comment">//记录将要删除的结点</span></span><br><span class="line">Double_Node&lt;T&gt;* will_delete_Next = will_delete-&gt;next;<span class="comment">//记录删除结点的下一个位置</span></span><br><span class="line">p_curr-&gt;next = will_delete-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (will_delete_Next != <span class="literal">nullptr</span>)<span class="comment">//删除结点是尾结点故跳过</span></span><br><span class="line">&#123;</span><br><span class="line">will_delete_Next-&gt;prior = p_curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; will_delete-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length--;       <span class="comment">//实际表长-1</span></span><br><span class="line"><span class="keyword">delete</span> will_delete;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Get_Elem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前双链表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">e = p_curr-&gt;data;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按元素值查找其在双链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Double_Link_List&lt;T&gt;::<span class="built_in">Locate_Elem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双链表中第一次出现的位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双链表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取双链表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span>  Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List_length</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双链表是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_head-&gt;next == <span class="literal">nullptr</span>) <span class="comment">//双链表为空（如果是不带头结点的双链表则用if(m_head == nullptr）来判断是否为空）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对双链表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Double_Link_List&lt;T&gt;::~<span class="built_in">Double_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">Double_Node&lt;T&gt;* ptmp;</span><br><span class="line"><span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)<span class="comment">//该循环负责释放数据节点</span></span><br><span class="line">&#123;</span><br><span class="line">ptmp = pnode;</span><br><span class="line">pnode = pnode-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> ptmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> m_head;    <span class="comment">//释放头结点</span></span><br><span class="line">m_head = <span class="literal">nullptr</span>; <span class="comment">//非必须</span></span><br><span class="line">m_length = <span class="number">0</span>;     <span class="comment">//非必须</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Double_Link_List&lt;T&gt;::<span class="built_in">Display_Double_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* p = m_head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>) <span class="comment">//这里采用while循环或者for循环书写都可以</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line">_nmsp::Double_Link_List&lt;<span class="type">int</span>&gt; Creat_D_L_List;</span><br><span class="line">Creat_D_L_List.<span class="built_in">Double_Link_List_insert</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">Creat_D_L_List.<span class="built_in">Double_Link_List_insert</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">Creat_D_L_List.<span class="built_in">Double_Link_List_insert</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">Creat_D_L_List.<span class="built_in">Display_Double_Link_List</span>();</span><br><span class="line">Creat_D_L_List.<span class="built_in">Double_Link_List_length</span>();</span><br><span class="line"></span><br><span class="line">Creat_D_L_List.<span class="built_in">Double_Link_List_delete</span>(<span class="number">1</span>);</span><br><span class="line">Creat_D_L_List.<span class="built_in">Display_Double_Link_List</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线性表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的实现（c++）</title>
      <link href="/archives/ac1d2ce8.html"/>
      <url>/archives/ac1d2ce8.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是单链表"><a href="#什么是单链表" class="headerlink" title="什么是单链表"></a>什么是单链表</h1><ul><li>我们知道顺序表的最大的缺点是插入和删除操作可能移动大量的元素，会导致程序的执行效率很低。导致程序低效的原因就是顺序表的元素必须连续且不能有间隙，建立一个顺序表的时候需要在内存中很大一片连续空的空间进行创造。</li><li>线性表的链式存储不需要使用连续的内存空间，链式存储是是通过“链”也就是指针的指向来建立各个相邻元素的关系，使其保证元素之间像一条线一样按顺序排列。<ul><li>优点：我们在插入和删除元素的时候，就不需要进行大量的数据元素的迁移，只需改变修改元素的（结点）的指针的指向。</li><li>缺点：结点结构比顺序表的结点结构要复杂一点。</li></ul></li></ul><hr><h1 id="单链表的数据成员"><a href="#单链表的数据成员" class="headerlink" title="单链表的数据成员"></a>单链表的数据成员</h1><ul><li>一个结点包含一个数据域和一个指针域（指针的内容是指向下一个结点的地址）</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">T data;<span class="comment">//数据域</span></span><br><span class="line">Node&lt;T&gt;* next;<span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h1><ul><li><p>单链表的类的定义和设计</p><ul><li><p>构造函数</p></li><li><p>析构函数</p></li><li><p>插入元素</p><ul><li>在第i个位置插入元素</li><li>快速在尾部插入元素</li><li>在已知结点之前插入元素</li></ul></li><li><p>删除第i个位置的元素</p></li><li><p>获取元素</p></li><li><p>按元素值查找第一次出现的位置</p></li><li><p>展示链表所有元素</p></li><li><p>获取链表的长度</p></li><li><p>判断链表是否为空</p></li><li><p>翻转链表</p></li><li><p>查看尾指针</p></li></ul></li></ul><hr><h1 id="单链表的编程实现"><a href="#单链表的编程实现" class="headerlink" title="单链表的编程实现"></a>单链表的编程实现</h1><h2 id="单链表类的定义"><a href="#单链表类的定义" class="headerlink" title="单链表类的定义"></a>单链表类的定义</h2><p>(这个版本是包含了尾指针的)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义单链表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Link_List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Link_List</span>();  <span class="comment">//构造函数</span></span><br><span class="line">~<span class="built_in">Link_List</span>();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="comment">//按位置插入元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//在第i个位置插入元素</span></span><br><span class="line"><span class="comment">//快速在尾部插入元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Link_List_Insert_Back</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="comment">//在已知的结点之前插入元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Prior_Insert_Node</span><span class="params">(<span class="type">const</span> T&amp; e, Node&lt;T&gt;*purr )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Delete</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line"><span class="function">T <span class="title">Get_Link_List_Elem</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//获取第i个元素的值</span></span><br><span class="line"><span class="function">Node&lt;T&gt;* <span class="title">Get_Link_List_point</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//获取第i个元素的指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按照元素值查找链表中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locate_Link_List_Elem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出链表所有的元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display_Link_List</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取链表的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Link_List_length</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse_Link_List</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看尾指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;T&gt;* m_head;<span class="comment">//单链表的头指针</span></span><br><span class="line"><span class="type">int</span> m_length;<span class="comment">//单链表的实际长度</span></span><br><span class="line"> Node&lt;T&gt;* m_rear ;<span class="comment">//单链表的尾指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-构造函数（初始化）"><a href="#1-构造函数（初始化）" class="headerlink" title="1)构造函数（初始化）"></a>1)构造函数（初始化）</h2><ul><li>首先会开辟一个内存存储结点，并让头指针指向它</li><li>因为是第一个结点，又是链表，头结点的指针域暂时指向nullptr</li><li>记录链表长度（头结点不算入）</li><li>尾指针指向链表尾部，初始化指向头结点（尾指针永远指向尾部）</li><li>注意事项：链表只要<strong>进行结构的变化</strong>（比如说进行删除结点，插入结点）一定要<strong>及时更新链表的长度和尾指针的指向</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Link_List&lt;T&gt;::<span class="built_in">Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_head = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">//头指针初始化并指向开辟一个内存</span></span><br><span class="line">m_head-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//头结点是链表的第0个结点，此时也是尾结点</span></span><br><span class="line">m_length = <span class="number">0</span>;<span class="comment">//头结点不算入实际长度</span></span><br><span class="line">m_rear = m_head;<span class="comment">//尾指针指向尾结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-析构函数"><a href="#2-析构函数" class="headerlink" title="2)析构函数"></a>2)析构函数</h2><ul><li>对链表中每个结点都必须进行释放</li><li>释放的同时，表的长度更新为0</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//析构函数进行释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Link_List&lt;T&gt;::~<span class="built_in">Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对链表中的每个结点都需要进行释放</span></span><br><span class="line">Node&lt;T&gt;* pnode = m_head-&gt;next;<span class="comment">//记录下一个结点的指向</span></span><br><span class="line">Node&lt;T&gt;* ptemp;<span class="comment">//记录释放的结点</span></span><br><span class="line"><span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">ptemp = pnode;</span><br><span class="line">pnode = pnode-&gt;next;<span class="comment">//更新结点</span></span><br><span class="line"><span class="keyword">delete</span> ptemp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> m_head;</span><br><span class="line">m_head = <span class="literal">nullptr</span>;<span class="comment">//非必须，建议</span></span><br><span class="line">m_rear = <span class="literal">nullptr</span>;<span class="comment">//非必须，建议</span></span><br><span class="line">m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3)插入元素"></a>3)插入元素</h2><ul><li>头部插入，尾部插入，中间元素插入均可适用  **在第i个位置插入元素 **这个版本</li><li><strong>快速在尾部插入元素</strong>  与  <strong>在第i个位置插入元素</strong>的尾部插入是一样的，只是少了个形参</li><li><strong>在已知的结点之前插入元素</strong>   设计这个目的是时间复杂度O（1），就不需要去遍历单链表的所有元素</li><li>上述的头部插入时间复杂度为O（1）；尾部插入是因为设计了一个尾指针永远指向尾部结点，则尾部插入也是O（1）；中间插入结点 需要去遍历链表找到该位置的前一个结点，则时间复杂度为O（n）</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="comment">//在第i个位置插入元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="comment">//快速在尾部插入元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Link_List_Insert_Back</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="comment">//在已知的结点之前插入元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Prior_Insert_Node</span><span class="params">(<span class="type">const</span> T&amp; e, Node&lt;T&gt;*purr )</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="4-在第i个位置插入元素"><a href="#4-在第i个位置插入元素" class="headerlink" title="4)在第i个位置插入元素"></a>4)在第i个位置插入元素</h3><ul><li>判断位置i是否合法</li><li>判断第i个位置是否为单链表尾部，是则调用  <strong>快速在尾部插入元素</strong></li><li>如果i &#x3D;1相当于头插法</li><li>更新表长；如果是尾部插入，在  <strong>快速在尾部插入元素</strong>  里面<strong>已经更新</strong>了尾指针的指向和单链表的表长；<strong>不是尾部插入只需要更新单链表长</strong></li><li>i&#x3D; 1，时间复杂度为O（1）；尾部插入，时间复杂度为O（1）；其他位置插入的平均时间复杂度为O（n)</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在第i个位置插入元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Insert</span>(<span class="type">int</span> i ,<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">i</span>&lt;<span class="number">1</span> || i&gt;(m_length + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span></span><br><span class="line">&lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是要插入尾指针之后</span></span><br><span class="line"><span class="comment">//如果i= 表长+1 ：代表就插入在尾处，相当于单链表的尾插法</span></span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">1</span> == m_length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Link_List_Insert_Back</span>( e);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;<span class="comment">//新建一个指针的目的是为指向第（i-1)的结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始定位第i-1位置的结点</span></span><br><span class="line"><span class="comment">//如果i=1，直接跳过for循环，在头结点下一个位置插入，相当于单链表的头插法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">//开辟一个新的内存存储要插入的结点</span></span><br><span class="line">node-&gt;data = e;<span class="comment">//存储数据域</span></span><br><span class="line">node-&gt;next = p_curr-&gt;next;<span class="comment">//以下两步指针域指向赋值顺序不可颠倒</span></span><br><span class="line">p_curr-&gt;next = node;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;<span class="comment">//更新表长</span></span><br></pre></td></tr></table></figure><h3 id="5-快速在尾部插入元素"><a href="#5-快速在尾部插入元素" class="headerlink" title="5)快速在尾部插入元素"></a>5)快速在尾部插入元素</h3><ul><li>核心步骤都是一样的</li><li>时间复杂度为O（1）</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Insert_Back</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">//存储新节点</span></span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = m_rear-&gt;next;</span><br><span class="line">m_rear-&gt;next = node;</span><br><span class="line">m_rear = node;<span class="comment">//更新尾指针</span></span><br><span class="line"><span class="keyword">if</span> (m_rear-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;尾部插入元素成功，更新尾指针成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">m_length++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-在已知结点之前插入元素"><a href="#6-在已知结点之前插入元素" class="headerlink" title="6)在已知结点之前插入元素"></a>6)在已知结点之前插入元素</h3><ul><li>先判断结点是否是尾结点</li><li>先将这个新结点插入到已知结点之后</li><li>然后将其已知结点和新结点的数据域进行交换</li><li>时间复杂度为O(1)</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//已知结点插入元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T &gt; </span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Prior_Insert_Node</span>(<span class="type">const</span> T&amp; e, Node&lt;T&gt;* purr )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//链表末尾插入（防止已知结点是尾结点）</span></span><br><span class="line"><span class="keyword">if</span> (purr-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Link_List_Insert_Back</span>( e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在purr结点之前插入新结点</span></span><br><span class="line"><span class="comment">//先将新结点插入到已知结点之后</span></span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = purr-&gt;next;</span><br><span class="line">purr-&gt;next = node;</span><br><span class="line"><span class="built_in">Display_Link_List</span>();</span><br><span class="line"><span class="comment">//交换数据域</span></span><br><span class="line">T temp = node-&gt;data;</span><br><span class="line">node-&gt;data = purr-&gt;data;</span><br><span class="line">purr-&gt;data = temp;</span><br><span class="line">m_length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序是便于获得某个元素的指向来作为上一个程序的形参来进行检验的</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得第i个位置的元素,返回指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Node&lt;T&gt;* Link_List&lt;T&gt;:: <span class="built_in">Get_Link_List_point</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p_curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="7-删除第i个位置的元素"><a href="#7-删除第i个位置的元素" class="headerlink" title="7)删除第i个位置的元素"></a>7)删除第i个位置的元素</h2><ul><li><p>判断链表是否为空</p></li><li><p>判断位置i是否为链表的合法位置</p></li><li><p>遍历链表找第i-1个位置的元素</p><ul><li>如果 i &#x3D;表长，则说明删除的结点是尾结点，则需要更新尾指针，和前一个结点的指针域赋值为nullptr</li></ul></li><li><p>更新表长</p></li><li><p>释放要删除的结点</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Delete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (m_length == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;链表为空不可删除元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断删除是否合法位置</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> </span><br><span class="line">&lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到第（i-1）位置结点的指向</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;  <span class="comment">//指向第i-1位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针域指向操作</span></span><br><span class="line">Node&lt;T&gt;* will_delete = p_curr-&gt;next;  <span class="comment">//will_delete指向第i个位置结点</span></span><br><span class="line">p_curr-&gt;next = will_delete-&gt;next;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> </span><br><span class="line">&lt;&lt; will_delete-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新尾指针</span></span><br><span class="line"><span class="keyword">if</span> (i == m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;说明删除的是尾结点,需要更新尾指针&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_rear = p_curr;</span><br><span class="line"><span class="keyword">if</span> (m_rear-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;更新尾结点成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m_length--;<span class="comment">//表长-1</span></span><br><span class="line"><span class="comment">//释放删除的结点</span></span><br><span class="line"><span class="keyword">delete</span> will_delete;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="8-获取元素"><a href="#8-获取元素" class="headerlink" title="8)获取元素"></a>8)获取元素</h2><ul><li>判断链表是否为空</li><li>判断位置i是否为链表的合法位置</li><li>遍历寻找</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得第i个位置的元素,返回值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Link_List&lt;T&gt;::<span class="built_in">Get_Link_List_Elem</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前单链表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span></span><br><span class="line">&lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)<span class="comment">//这里是i不是i-1</span></span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> </span><br><span class="line">&lt;&lt; p_curr-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> p_curr-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="9-按元素值查找第一次出现的位置"><a href="#9-按元素值查找第一次出现的位置" class="headerlink" title="9)按元素值查找第一次出现的位置"></a>9)按元素值查找第一次出现的位置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照元素值查找链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Link_List&lt;T&gt;::<span class="built_in">Locate_Link_List_Elem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; i++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;data == e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单链表中第一次出现的位置为&quot;</span> </span><br><span class="line">&lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单链表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="10-展示链表所有元素"><a href="#10-展示链表所有元素" class="headerlink" title="10)展示链表所有元素"></a>10)展示链表所有元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出链表所有的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">Display_Link_List</span>() </span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* p = m_head;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;单链表所有元素展示：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="11-获取链表的长度"><a href="#11-获取链表的长度" class="headerlink" title="11)获取链表的长度"></a>11)获取链表的长度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取链表的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_length</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-判断链表是否为空"><a href="#12-判断链表是否为空" class="headerlink" title="12)判断链表是否为空"></a>12)判断链表是否为空</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;:: <span class="built_in">Link_List_Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_head-&gt;next == <span class="literal">nullptr</span>) <span class="comment">//单链表为空（如果是不带头结点的单</span></span><br><span class="line"><span class="comment">//链表则用if(m_head == nullptr）来判断是否为空）</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;单链表不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="13-翻转链表"><a href="#13-翻转链表" class="headerlink" title="13)翻转链表"></a>13)翻转链表</h2><p>以a0 a1 a2 a3 a4为例，其中a0为头结点</p><ul><li><p>判断单链表是否为空或者只有一个元素</p></li><li><p>将头结点和第二个结点作为一个整体（a0和a1），翻转过后a1作为最后一个元素，则a1的指针域为nullptr，尾指针也要更新为a1</p></li><li><p>后续只要改变的a2元素的指针域的指向（和头插法的步骤一致），同时也要更新要处理的结点也就是a3</p><p><img src="https://cdn.jsdelivr.net/gh/chuannihaoa/picog/image20221028125057.png" alt="反转链表"></p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 翻转链表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">Reverse_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果没有顺序表中没有元素或者只有一个元素，那么就不用做任何操作</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p2 = m_head-&gt;next-&gt;next;<span class="comment">// 获取指向第二个结点的指针域</span></span><br><span class="line">m_head-&gt;next-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//将第一个结点的指针域赋值为空（作为最后一个结点）</span></span><br><span class="line">m_rear = m_head-&gt;next;<span class="comment">//更新尾指针</span></span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr;</span><br><span class="line"><span class="comment">//只要改变第二个结点的指针域指向，便可改变顺序</span></span><br><span class="line"><span class="comment">//具体步骤和头插法一致</span></span><br><span class="line"><span class="keyword">while</span> (p2 != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p2;<span class="comment">//当前（假设a2)赋给p_curr指针进行插入操作</span></span><br><span class="line">p2 = p2 -&gt; next;<span class="comment">//更新结点</span></span><br><span class="line"> </span><br><span class="line">p_curr-&gt;next = m_head-&gt;next;</span><br><span class="line">m_head-&gt;next = p_curr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-查看尾指针"><a href="#14-查看尾指针" class="headerlink" title="14)查看尾指针"></a>14)查看尾指针</h2><ul><li>主要用于查看是否正确</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">rear</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; 链表最后一个元素为&quot;</span>&lt;&lt;m_rear-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);<span class="comment">//程序退出时检测内存泄漏并显示到“输出”窗口</span></span><br><span class="line">_nmsp::Link_List&lt;<span class="type">int</span>&gt; Creat_link;</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> length = Creat_link.<span class="built_in">Link_List_length</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;单链表长度为&quot;</span> &lt;&lt; length &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Reverse_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Get_Link_List_Elem</span>(<span class="number">3</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Empty</span>();</span><br><span class="line">Creat_link.<span class="built_in">Locate_Link_List_Elem</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Link_List_Delete</span>(<span class="number">6</span>);</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line"></span><br><span class="line">_nmsp::Node&lt;<span class="type">int</span>&gt; * node = Creat_link.<span class="built_in">Get_Link_List_point</span>(<span class="number">4</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Prior_Insert_Node</span>(<span class="number">1000</span>, node);</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>并不需要大片的连续存储空间来存放数据元素，扩容很方便</p></li><li><p>插入和删除结点相对于顺序表来说很方便，平均时间复杂度为O（n），如果是头部插入和尾部插入和在已知结点插入，那么时间复杂度就为O（1），这也就说明链表更适合插入，删除的频繁操作</p></li><li><p>存放后后继指针要额外的消耗存储空间，体现了利用空间来换时间来提高算法效率的编程思想</p></li><li><p>单链表也有一个很大的弊端，它的内存空间不连续，无法实现随机访问单链表中的元素，如果要访问某个结点只能从链表中第一个结点开始往下进行遍历，单链表的主要时间都花在了遍历元素的方面，平均时间复杂度为O（n).</p></li></ul><hr><h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> _nmsp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">T data;</span><br><span class="line">Node&lt;T&gt;* next;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义单链表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Link_List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Link_List</span>();  <span class="comment">//构造函数</span></span><br><span class="line">~<span class="built_in">Link_List</span>();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="comment">//按位置插入元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//在第i个位置插入元素</span></span><br><span class="line"><span class="comment">//快速在尾部插入元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Link_List_Insert_Back</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="comment">//在已知的结点之前插入元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Prior_Insert_Node</span><span class="params">(<span class="type">const</span> T&amp; e, Node&lt;T&gt;* purr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Delete</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line"><span class="function">T <span class="title">Get_Link_List_Elem</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//获取第i个元素的值</span></span><br><span class="line"><span class="function">Node&lt;T&gt;* <span class="title">Get_Link_List_point</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//获取第i个元素的指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按照元素值查找链表中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locate_Link_List_Elem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出链表所有的元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display_Link_List</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取链表的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Link_List_length</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse_Link_List</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看尾指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;T&gt;* m_head;<span class="comment">//单链表的头指针</span></span><br><span class="line"><span class="type">int</span> m_length;<span class="comment">//单链表的实际长度</span></span><br><span class="line">Node&lt;T&gt;* m_rear;<span class="comment">//单链表的尾指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Link_List&lt;T&gt;::<span class="built_in">Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_head = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">//头指针初始化并指向开辟一个内存</span></span><br><span class="line">m_head-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//头结点是链表的第0个结点，此时也是尾结点</span></span><br><span class="line">m_length = <span class="number">0</span>;<span class="comment">//头结点不算入实际长度</span></span><br><span class="line">m_rear = m_head;<span class="comment">//尾指针指向尾结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第i个位置插入元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Insert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">i</span>&lt;<span class="number">1</span> || i&gt;(m_length + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span></span><br><span class="line">&lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是要插入尾指针之后</span></span><br><span class="line"><span class="comment">// 如果i= 表长+1 ：代表就插入在尾处，相当于单链表的尾插法</span></span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">1</span> == m_length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Link_List_Insert_Back</span>(e);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;<span class="comment">//新建一个指针的目的是为指向第（i-1)的结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始定位第i-1位置的结点</span></span><br><span class="line"><span class="comment">//如果i=1，直接跳过for循环，在头结点下一个位置插入，相当于单链表的头插法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">//开辟一个新的内存存储要插入的结点</span></span><br><span class="line">node-&gt;data = e;<span class="comment">//存储数据域</span></span><br><span class="line">node-&gt;next = p_curr-&gt;next;<span class="comment">//以下两步指针域指向赋值顺序不可颠倒</span></span><br><span class="line">p_curr-&gt;next = node;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;<span class="comment">//更新表长</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速在尾部插入元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Insert_Back</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = m_rear-&gt;next;</span><br><span class="line">m_rear-&gt;next = node;</span><br><span class="line">m_rear = node;</span><br><span class="line"><span class="keyword">if</span> (m_rear-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;尾部插入元素成功，更新尾指针成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">m_length++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已知结点插入元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Prior_Insert_Node</span>(<span class="type">const</span> T&amp; e, Node&lt;T&gt;* purr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 链表末尾插入（防止已知结点是尾结点）</span></span><br><span class="line"><span class="keyword">if</span> (purr-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Link_List_Insert_Back</span>(e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在purr结点之前插入新结点</span></span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = purr-&gt;next;</span><br><span class="line">purr-&gt;next = node;</span><br><span class="line"><span class="built_in">Display_Link_List</span>();</span><br><span class="line"><span class="comment">// 交换数据域</span></span><br><span class="line">T temp = node-&gt;data;</span><br><span class="line">node-&gt;data = purr-&gt;data;</span><br><span class="line">purr-&gt;data = temp;</span><br><span class="line">m_length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Delete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (m_length == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;链表为空不可删除元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断删除是否合法位置</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span></span><br><span class="line">&lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第（i-1）位置结点的指向</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;  <span class="comment">//指向第i-1位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针域指向操作</span></span><br><span class="line">Node&lt;T&gt;* will_delete = p_curr-&gt;next;  <span class="comment">//will_delete指向第i个位置结点</span></span><br><span class="line">p_curr-&gt;next = will_delete-&gt;next;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span></span><br><span class="line">&lt;&lt; will_delete-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新尾指针</span></span><br><span class="line"><span class="keyword">if</span> (i == m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;说明删除的是尾结点,需要更新尾指针&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_rear = p_curr;</span><br><span class="line"><span class="keyword">if</span> (m_rear-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;更新尾结点成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m_length--;<span class="comment">//表长-1</span></span><br><span class="line"><span class="comment">// 释放删除的结点</span></span><br><span class="line"><span class="keyword">delete</span> will_delete;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得第i个位置的元素,返回值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Link_List&lt;T&gt;::<span class="built_in">Get_Link_List_Elem</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前单链表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span></span><br><span class="line">&lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span></span><br><span class="line">&lt;&lt; p_curr-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> p_curr-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得第i个位置的元素,返回指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Node&lt;T&gt;* Link_List&lt;T&gt;::<span class="built_in">Get_Link_List_point</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p_curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照元素值查找链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Link_List&lt;T&gt;::<span class="built_in">Locate_Link_List_Elem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; i++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;data == e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单链表中第一次出现的位置为&quot;</span></span><br><span class="line">&lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单链表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出链表所有的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">Display_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* p = m_head;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;单链表所有元素展示：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_length</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_head-&gt;next == <span class="literal">nullptr</span>) <span class="comment">//单链表为空（如果是不带头结点的单</span></span><br><span class="line"><span class="comment">//链表则用if(m_head == nullptr）来判断是否为空）</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;单链表不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转链表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">Reverse_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果没有顺序表中没有元素或者只有一个元素，那么就不用做任何操作</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p2 = m_head-&gt;next-&gt;next;<span class="comment">// 获取指向第二个结点的指针域</span></span><br><span class="line">m_head-&gt;next-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//将第一个结点的指针域赋值为空（作为最后一个结点）</span></span><br><span class="line">m_rear = m_head-&gt;next;<span class="comment">//更新尾指针</span></span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr;</span><br><span class="line"><span class="comment">// 只要改变第二个结点的指针域指向，便可改变顺序</span></span><br><span class="line"><span class="comment">// 具体步骤和头插法一致</span></span><br><span class="line"><span class="keyword">while</span> (p2 != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p2;<span class="comment">//当前（假设a2)赋给p_curr指针进行插入操作</span></span><br><span class="line">p2 = p2-&gt;next;<span class="comment">//更新结点</span></span><br><span class="line"></span><br><span class="line">p_curr-&gt;next = m_head-&gt;next;</span><br><span class="line">m_head-&gt;next = p_curr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数进行释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Link_List&lt;T&gt;::~<span class="built_in">Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 对链表中的每个结点都需要进行释放</span></span><br><span class="line">Node&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">Node&lt;T&gt;* ptemp;</span><br><span class="line"><span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">ptemp = pnode;</span><br><span class="line">pnode = pnode-&gt;next;<span class="comment">//更新结点</span></span><br><span class="line"><span class="keyword">delete</span> ptemp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> m_head;</span><br><span class="line">m_head = <span class="literal">nullptr</span>;</span><br><span class="line">m_rear = <span class="literal">nullptr</span>;</span><br><span class="line">m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">rear</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; 链表最后一个元素为&quot;</span> &lt;&lt; m_rear-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);<span class="comment">//程序退出时检测内存泄漏并显示到“输出”窗口</span></span><br><span class="line">_nmsp::Link_List&lt;<span class="type">int</span>&gt; Creat_link;</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> length = Creat_link.<span class="built_in">Link_List_length</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;单链表长度为&quot;</span> &lt;&lt; length &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Reverse_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Get_Link_List_Elem</span>(<span class="number">3</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Empty</span>();</span><br><span class="line">Creat_link.<span class="built_in">Locate_Link_List_Elem</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Link_List_Delete</span>(<span class="number">6</span>);</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line"></span><br><span class="line">_nmsp::Node&lt;<span class="type">int</span>&gt;* node = Creat_link.<span class="built_in">Get_Link_List_point</span>(<span class="number">4</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Prior_Insert_Node</span>(<span class="number">1000</span>, node);</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线性表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表的实现（c++）</title>
      <link href="/archives/b4bd089e.html"/>
      <url>/archives/b4bd089e.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是顺序表"><a href="#什么是顺序表" class="headerlink" title="什么是顺序表"></a>什么是顺序表</h1><ul><li>一个最简单的例子就是一维数组，它的特点就是在内存中进行<strong>顺序存储</strong></li><li>在一块内存中，进行顺序存储的线性表就是顺序表</li><li>在任意时刻，数组的长度就是顺序表的最大存储容量</li></ul><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG<span class="comment">//只有在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__)<span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="comment">//当进行对象转储时，用 DEBUG_NEW 分配的每个对象均将显示被分配到的文件和行号，使您可以查明内存泄漏源</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW    </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10<span class="comment">//动态数组的初始大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IncSize 5<span class="comment">//当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span></span><br></pre></td></tr></table></figure><hr><h1 id="顺序表的数据成员-两种写法"><a href="#顺序表的数据成员-两种写法" class="headerlink" title="顺序表的数据成员(两种写法)"></a>顺序表的数据成员(两种写法)</h1><ul><li><p>静态数组</p><ul><li><p>建立一个一维数组，来保存顺序表的元素</p></li><li><p>建立一个变量存储顺序表当前的实际长度（不是数组的长度，数组长度是已知的）</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_data[<span class="number">10</span>];  <span class="comment">//静态数组保存顺序表中的元素，一共10个位置</span></span><br><span class="line"><span class="type">int</span> m_length;<span class="comment">//顺序表中当前的实际长度</span></span><br><span class="line"></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure><ul><li>动态数组（通常都采用这种写法）<ul><li>用指针进行建立数组内存</li><li>动态数组可以进行扩容</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>* m_data;       <span class="comment">//顺序表中的元素保存在m_data所指向的动态数组内存中</span></span><br><span class="line"><span class="type">int</span> m_length;<span class="comment">//顺序表当前的实际长度</span></span><br><span class="line"><span class="type">int</span> m_maxsize;<span class="comment">//动态数组最大容量，因为动态数组可以扩容，因此要记录该值</span></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure><hr><h1 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h1><ul><li>顺序表的类的定义和设计<ul><li>构造函数</li><li>析构函数</li><li>按指定位置i插入元素</li><li>按指定位置i删除元素</li><li>获取第i位置的元素</li><li>按元素值查找在顺序表的第一次出现的位置</li><li>遍历输出顺序表的元素</li><li>获取顺序表的长度</li><li>反转顺序表</li><li>扩容操作</li></ul></li></ul><hr><h1 id="顺序表的编程实现"><a href="#顺序表的编程实现" class="headerlink" title="顺序表的编程实现"></a>顺序表的编程实现</h1><h2 id="类（顺序表-定义"><a href="#类（顺序表-定义" class="headerlink" title="类（顺序表)定义"></a>类（顺序表)定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SeqList</span>(<span class="type">int</span> length = InitSize);<span class="comment">//构造函数</span></span><br><span class="line">~<span class="built_in">SeqList</span>();<span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List_Insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//在第i个位置插入新元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List_Delete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Get_List_Elem</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//获取第i个位置的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locate_Elem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//按元素值查找在顺序表的第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display_List</span><span class="params">()</span></span>;<span class="comment">//输出顺序表中的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_List_Length</span><span class="params">()</span></span>;<span class="comment">//获取顺序表的长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse_List</span><span class="params">()</span></span>;<span class="comment">//反转顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increase_Size</span><span class="params">()</span></span>;<span class="comment">//扩容操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_data;<span class="comment">//（指向存放顺序表的当中的元素</span></span><br><span class="line"><span class="type">int</span> m_length;<span class="comment">//顺序表中当前实际长度（当前有几个元素）</span></span><br><span class="line"><span class="type">int</span> m_maxsize;<span class="comment">//动态数组的最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="构造函数（初始化）"><a href="#构造函数（初始化）" class="headerlink" title="构造函数（初始化）"></a>构造函数（初始化）</h2><ul><li>首先会开辟一块内存来存储顺序表</li><li>为当前顺序表长度赋初值为0</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数对顺序表进行初始化template &lt;typename T&gt;</span></span><br><span class="line">SeqList&lt;T&gt;::<span class="built_in">SeqList</span>(<span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">m_data = <span class="keyword">new</span> T[length]; <span class="comment">//为一维数组动态分配内存</span></span><br><span class="line">m_length = <span class="number">0</span>;           <span class="comment">//顺序表当前实际长度为0，表示还未向其中存入任何数据元素</span></span><br><span class="line">m_maxsize = length;     <span class="comment">//顺序表最多可以存储m_maxsize个数据元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul><li>必须对用户自己分配好的内存空间进行释放</li><li><strong>delete m_data 和delete []m_data的区别</strong><ul><li>delete m_data <strong>释放了m_data指针指向的全部内存空间 但是只调用了m_data[0]对象的析构函数 剩下的从[1]到末尾这个用户自行分配的对应内存空间将不能释放</strong>， 从而造成内存泄漏。</li><li>delete []m_data <strong>&#x2F;调用使用类对象的析构函数释放用户自己分配内存空间并且  释放了m_data指针指向的全部内存空间</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过析构函数对顺序表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqList&lt;T&gt;::~<span class="built_in">SeqList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">m_length = <span class="number">0</span>; <span class="comment">//非必须</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="按指定位置i插入元素"><a href="#按指定位置i插入元素" class="headerlink" title="按指定位置i插入元素"></a>按指定位置i插入元素</h2><ol><li><p>先判断顺序表是否存满数据；是，进行扩容操作</p></li><li><p>判断i这个位置是否合法</p></li><li><p>以上都满足进行插入操作</p><ul><li><p>从最后一个元素遍历到下标为i的位置（也就是第i+1个元素）结束进行元素位置向后移位</p></li><li><p>对第i个位置进行赋值</p></li><li><p>每一次进行插入 操作，顺序表长+1</p></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在第i个位置（位置编号从1开始）插入指定元素e，时间复杂度：O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果顺序表已经存满了数据，则不允许再插入新数据了</span></span><br><span class="line"><span class="keyword">if</span> (m_length &gt;= m_maxsize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;顺序表已满，不能再进行插入操作了!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="built_in">IncreaseSize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断插入位置i是否合法，i的合法值应该是1到m_length+1之间</span></span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; (m_length+<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt;<span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt;   m_length+<span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从最后一个元素开始向前遍历到要插入新元素的第i个位置，</span></span><br><span class="line"><span class="comment">//分别将这些位置中原有的元素向后移动一个位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = m_length; j &gt;= i; --j) </span><br><span class="line">&#123;</span><br><span class="line">m_data[j] = m_data[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">m_data[i<span class="number">-1</span>] = e;   <span class="comment">//在指定位置i处插入元素e</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;        <span class="comment">//实际表长+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="按指定位置i删除元素"><a href="#按指定位置i删除元素" class="headerlink" title="按指定位置i删除元素"></a>按指定位置i删除元素</h2><ul><li>判断表是否为空</li><li>判断位置i是否合法</li><li>以上都满足，遍历第i+1个位置到顺序表末尾向前移位</li><li>每次删除操作顺序表长都必须-1</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序表为空，不能删除任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//从数组中第i+1个位置开始向后遍历所有元素，分别将这些位置中原有的元素向前移动一个位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i ; j &lt; m_length; ++j)</span><br><span class="line">&#123;</span><br><span class="line">m_data[j<span class="number">-1</span>] = m_data[j];</span><br><span class="line">&#125;</span><br><span class="line">m_length--;       <span class="comment">//实际表长-1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="获取第i个位置的元素值"><a href="#获取第i个位置的元素值" class="headerlink" title="获取第i个位置的元素值"></a>获取第i个位置的元素值</h2><ul><li>判断表是否为空</li><li>判断位置i是否合法</li><li>以上都满足，成功获取值</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e) <span class="comment">//参数e是引用类型参数，确保将该值带回调用者</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt;   <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = m_data[i<span class="number">-1</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="按元素值查找在顺序表的第一次出现的位置"><a href="#按元素值查找在顺序表的第一次出现的位置" class="headerlink" title="按元素值查找在顺序表的第一次出现的位置"></a>按元素值查找在顺序表的第一次出现的位置</h2><ul><li>是按照元素值进行查找，则对其全部进行遍历一一对比</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按元素值查找其在顺序表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_data[i] == e)</span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在顺序表中第一次出现的位置为&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">//返回的位置应该用数组下标值+1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在顺序表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="遍历输出顺序表的元素"><a href="#遍历输出顺序表的元素" class="headerlink" title="遍历输出顺序表的元素"></a>遍历输出顺序表的元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出顺序表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="获取顺序表的长度"><a href="#获取顺序表的长度" class="headerlink" title="获取顺序表的长度"></a>获取顺序表的长度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取顺序表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="反转顺序表"><a href="#反转顺序表" class="headerlink" title="反转顺序表"></a>反转顺序表</h2><ul><li>判断顺序是否为空</li><li>第一个和最后一个交换赋值，依次类推</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//翻转顺序表，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">ReverseList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果没有顺序表中没有元素或者只有一个元素，那么就不用做任何操作</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">T temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length / <span class="number">2</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">temp = m_data[i];</span><br><span class="line">m_data[i] = m_data[m_length - i - <span class="number">1</span>];</span><br><span class="line">m_data[m_length - i - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h2><ul><li>新建一个指针指向原来顺序表的数据的内存块</li><li>新开辟一个内存的同时要扩容一下大小</li><li>然后在遍历原来内存将其数据复制到已经新的内存（新扩容的内存）</li><li>释放原来的内存块</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当顺序表存满数据后可以调用此函数为顺序表扩容，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">IncreaseSize</span>()</span><br><span class="line">&#123;</span><br><span class="line">T* p = m_data;</span><br><span class="line">m_data = <span class="keyword">new</span> T[m_maxsize + IncSize]; <span class="comment">//重新为顺序表分配更大的内存空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; i++)</span><br><span class="line">&#123;</span><br><span class="line">m_data[i] = p[i];                <span class="comment">//将数据复制到新区域</span></span><br><span class="line">&#125;</span><br><span class="line">m_maxsize = m_maxsize + IncSize;     <span class="comment">//顺序表最大长度增加IncSize</span></span><br><span class="line"><span class="keyword">delete</span>[] p;                          <span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主函数操作"><a href="#主函数操作" class="headerlink" title="主函数操作"></a>主函数操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line"><span class="comment">//程序退出时检测内存泄漏并显示到“输出”窗口</span></span><br><span class="line"></span><br><span class="line"><span class="function">_nmsp1::SeqList&lt;<span class="type">int</span>&gt; <span class="title">seqobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">30</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">seqobj.<span class="built_in">ListDelete</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">seqobj.<span class="built_in">GetElem</span>(<span class="number">1</span>, eval); <span class="comment">//如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> findvalue = <span class="number">10</span>; <span class="comment">//在顺序表中要找的元素值</span></span><br><span class="line">seqobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">seqobj.<span class="built_in">DispList</span>();</span><br><span class="line">cout &lt;&lt; seqobj.<span class="built_in">ListLength</span>() &lt;&lt; endl;</span><br><span class="line">seqobj.<span class="built_in">ReverseList</span>();</span><br><span class="line">seqobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">30</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(i, i*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">seqobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>顺序表的特点</p><ul><li>通过下标访问数据元素的时间复杂度为O（1）</li><li>插入和删除操作会移动大量元素时间复杂度为O（n）</li><li>需要大片的连续的内存空间来存储数据</li><li>扩容操作的具体数值的大小不好确定（大了导致内存浪费，小了会进行频繁的操作）</li></ul></li><li><p>应用：</p><ul><li>vector  大致思想原理是类似于顺序表</li></ul></li></ul><hr><h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;boost/type_index.hpp&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#pragma warning(disable : 4996) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10   <span class="comment">//动态数组的初始尺寸</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IncSize  5    <span class="comment">//当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//T代表数组中元素的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SeqList</span>(<span class="type">int</span> length=InitSize); <span class="comment">//构造函数，参数可以有默认值</span></span><br><span class="line">~<span class="built_in">SeqList</span>();                   <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">//在第i个位置插入指定元素e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;              <span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;           <span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T &amp;e)</span></span>;         <span class="comment">//按元素值查找其在顺序表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;                     <span class="comment">//输出顺序表中的所有元素</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">ListLength</span><span class="params">()</span></span>;                   <span class="comment">//获取顺序表的长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReverseList</span><span class="params">()</span></span>;                  <span class="comment">//翻转顺序表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">()</span></span>;                 <span class="comment">//当顺序表存满数据后可以调用此函数为顺序表扩容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T*  m_data;                   <span class="comment">//存放顺序表中的元素</span></span><br><span class="line"><span class="type">int</span> m_length;                 <span class="comment">//顺序表当前长度（当前有几个元素）</span></span><br><span class="line"><span class="type">int</span> m_maxsize;                <span class="comment">//动态数组最大容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数对顺序表进行初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqList&lt;T&gt;::<span class="built_in">SeqList</span>(<span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">m_data = <span class="keyword">new</span> T[length]; <span class="comment">//为一维数组动态分配内存</span></span><br><span class="line">m_length = <span class="number">0</span>;           <span class="comment">//顺序表当前实际长度为0，表示还未向其中存入任何数据元素</span></span><br><span class="line">m_maxsize = length;     <span class="comment">//顺序表最多可以存储m_maxsize个数据元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对顺序表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqList&lt;T&gt;::~<span class="built_in">SeqList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">m_length = <span class="number">0</span>; <span class="comment">//非必须</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置（位置编号从1开始）插入指定元素e，时间复杂度：O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_length &gt;= m_maxsize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;顺序表已满，不能再进行插入操作了!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="built_in">IncreaseSize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; (m_length+<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt;<span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length+<span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = m_length; j &gt;= i; --j) </span><br><span class="line">&#123;</span><br><span class="line">m_data[j] = m_data[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">m_data[i<span class="number">-1</span>] = e;   </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;        <span class="comment">//实际表长+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序表为空，不能删除任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i ; j &lt; m_length; ++j)</span><br><span class="line">&#123;</span><br><span class="line">m_data[j<span class="number">-1</span>] = m_data[j];</span><br><span class="line">&#125;</span><br><span class="line">m_length--;       <span class="comment">//实际表长-1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e) <span class="comment">//参数e是引用类型参数，确保将该值带回调用者</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = m_data[i<span class="number">-1</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按元素值查找其在顺序表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_data[i] == e)</span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在顺序表中第一次出现的位置为&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">//返回的位置应该用数组下标值+1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在顺序表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出顺序表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取顺序表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//翻转顺序表，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">ReverseList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">T temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length / <span class="number">2</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">temp = m_data[i];</span><br><span class="line">m_data[i] = m_data[m_length - i - <span class="number">1</span>];</span><br><span class="line">m_data[m_length - i - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当顺序表存满数据后可以调用此函数为顺序表扩容，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">IncreaseSize</span>()</span><br><span class="line">&#123;</span><br><span class="line">T* p = m_data;</span><br><span class="line">m_data = <span class="keyword">new</span> T[m_maxsize + IncSize]; <span class="comment">//重新为顺序表分配更大的内存空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; i++)</span><br><span class="line">&#123;</span><br><span class="line">m_data[i] = p[i];                <span class="comment">//将数据复制到新区域</span></span><br><span class="line">&#125;</span><br><span class="line">m_maxsize = m_maxsize + IncSize;     <span class="comment">//顺序表最大长度增加IncSize</span></span><br><span class="line"><span class="keyword">delete</span>[] p;                          <span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//程序退出时检测内存泄漏并显示到“输出”窗口</span></span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line"></span><br><span class="line"><span class="function">_nmsp1::SeqList&lt;<span class="type">int</span>&gt; <span class="title">seqobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">30</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">seqobj.<span class="built_in">ListDelete</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">seqobj.<span class="built_in">GetElem</span>(<span class="number">1</span>, eval); <span class="comment">//如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> findvalue = <span class="number">10</span>; <span class="comment">//在顺序表中要找的元素值</span></span><br><span class="line">seqobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">seqobj.<span class="built_in">DispList</span>();</span><br><span class="line">cout &lt;&lt; seqobj.<span class="built_in">ListLength</span>() &lt;&lt; endl;</span><br><span class="line">seqobj.<span class="built_in">ReverseList</span>();</span><br><span class="line">seqobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">30</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(i, i*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">seqobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线性表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Github+hexo教程</title>
      <link href="/archives/ce550664.html"/>
      <url>/archives/ce550664.html</url>
      
        <content type="html"><![CDATA[<h1 id="搭建GitHub-hexo的博客"><a href="#搭建GitHub-hexo的博客" class="headerlink" title="搭建GitHub+hexo的博客"></a>搭建GitHub+hexo的博客</h1><h2 id="什么是hexo"><a href="#什么是hexo" class="headerlink" title="什么是hexo"></a>什么是hexo</h2><ul><li><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，说的简单一点就是hexo具有markdown程序转换成HTML页面 </p></li><li><p>一般在自己电脑上会创建一个blog文件夹来作为本地仓库，github创建一个仓库，由本地部署到GitHub上面即可通过网址来进行访问。</p></li></ul><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li><p>事先看一遍b站视频</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1mU4y1j72n/spm_id_from=333.337.search-card.all.click   多看看这个视频的准备工作</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.999.0.0</span><br><span class="line">看这个过程进行一步一步的操作</span><br></pre></td></tr></table></figure></li><li><p>安装git （会用的git bash命令行进行操作）  </p></li><li><p>上GitHub官网申请一个账号（并且创建一个仓库）具体操作看第一个视频</p></li><li><p>安装node.js(选择长期版本的)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v  </span><br><span class="line">npm  -v</span><br><span class="line">//显示版本就代表安装成功</span><br><span class="line">npm是一个软件包管理器，在国内速度很慢因此安装cnpm并把指向国内淘宝的镜像源也就是第五步</span><br></pre></td></tr></table></figure></li><li><p>安装cnpm并指向淘宝镜像源</p><p>1. </p>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><p>   <img src="/archives/ce550664/111.png"></p></li></ol><p>安装成功</p><hr><p>出现这种情况，再来一次上面这个命令</p><p><img src="/archives/ce550664/222.png"></p><hr><p><img src="/archives/ce550664/333.png"></p><p>删除c盘下的npmrc文件！！！！ 记住是c盘下的。</p><p>然后在重复命令。</p><hr><ol><li><p>安装hexo框架</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo -cli</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo -v </span><br><span class="line">//显示版本号安装成功</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="搭建本地仓库"><a href="#搭建本地仓库" class="headerlink" title="搭建本地仓库"></a>搭建本地仓库</h1><ol><li><p>建立Blog文件夹（随便在那儿建立，但必须保证是空）</p></li><li><p>在Blog文件下打开git bash</p></li><li><p>hexo init（进行初始化，blog文件夹会显示一系列文件）</p></li><li><p>hexo s</p></li></ol><p><img src="/archives/ce550664/444.png"></p><p>在浏览器输入红色部分会得到一个静态网页。</p><ol start="5"><li><p>hexo n “川的第一篇博客”(创建一个博客，在blog&#x2F;source&#x2F;_posts可以对其文档修改)</p></li><li><p>hexo clean(清理一下缓存)</p></li><li><p>hexo g（生成静态网页）</p></li><li><p>hexo s（运行服务器）</p></li></ol><hr><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><ol><li><p>建立github仓库成功之后</p></li><li><p>在blog文文件夹下装一个部署的插件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li><li><p>修改blog文件夹下的配置文件_config.yml</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">看到<span class="comment">#Deloyment这里进行修改如下图</span></span><br></pre></td></tr></table></figure><p><img src="/archives/ce550664/555.png"></p></li><li><p>hexo d（部署成功）</p></li></ol><hr><hr><h1 id="解决图片不显示问题"><a href="#解决图片不显示问题" class="headerlink" title="解决图片不显示问题"></a>解决图片不显示问题</h1><ul><li>更改配置文件_config.yml</li></ul><p><img src="/archives/ce550664/666.jpg"></p><ul><li>在hexo n ”  xxxx “新建一个博客时，就会产生一个xxxx的文件夹来存储图片以便于在md文件中进行引用图片。</li></ul><p><img src="/archives/ce550664/777.jpg"></p><ul><li><p>再更改一个插件 hexo-asset-image </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/foreveryang321/hexo-asset-image.git --save</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>再按照部署条件进行操作</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>双循环链表的实现（c++）</title>
      <link href="/archives/1d2d9f6e.html"/>
      <url>/archives/1d2d9f6e.html</url>
      
        <content type="html"><![CDATA[<h1 id="双循环链表"><a href="#双循环链表" class="headerlink" title="双循环链表"></a>双循环链表</h1><ul><li><p>在双链表的基础上，将链表中的最后一个结点的后继指针由指向nullptr修改为指向头结点，将链表头结点的前趋指针由指向nullptr修改为指向最后一个结点，从而构成双循环链表。</p></li><li><p>与双链表的主要的改动是</p><ul><li>在于构造函数的头结点的next指针和prior指针初始化时指向自己。</li><li>判断是否为空应该是m_head-&gt;next &#x3D;&#x3D; m_head而不是m_head-&gt;next&#x3D;&#x3D; nullptr.</li><li>最关键的是插入和删除操作，要注意维护好最后一个结点的后继指针指向，保证其永远指向头结点，也要注意头结点的前趋指针的指向，保证其永远指向最后一个结点。除了头部和尾部的插入和删除操作，与双链表的的操作是一致的。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Double_Node</span></span><br><span class="line">&#123;</span><br><span class="line">T data;<span class="comment">//数据域</span></span><br><span class="line">Double_Node&lt;T&gt;* prior;<span class="comment">//前趋指针</span></span><br><span class="line">Double_Node &lt;T&gt;* next;<span class="comment">//后继指针</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Db_Cir_Link_List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Db_Cir_Link_List</span>();</span><br><span class="line">~<span class="built_in">Db_Cir_Link_List</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">//在第i个位置插入指定元素e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;              <span class="comment">//删除第i个位置的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;           <span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;         <span class="comment">//按元素值查找其在双循环链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;                     <span class="comment">//输出双循环链表中的所有元素</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">ListLength</span><span class="params">()</span></span>;                   <span class="comment">//获取双循环链表的长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;                        <span class="comment">//判断双循环链表是否为空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Double_Node&lt;T&gt;* m_head;</span><br><span class="line"><span class="type">int</span> m_length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Db_Cir_Link_List&lt;T&gt;::<span class="built_in">Db_Cir_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_head = <span class="keyword">new</span> Double_Node&lt;T&gt;;</span><br><span class="line">m_head-&gt;next = m_head;</span><br><span class="line">m_head-&gt;prior = m_head;</span><br><span class="line">m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Db_Cir_Link_List&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断插入位置i是否合法，i的合法值应该是1到length+1之间</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;*node = <span class="keyword">new</span> Double_Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = p_curr-&gt;next;</span><br><span class="line">node-&gt;prior = p_curr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为是循环的，就不需要进行if(p_curr-&gt;next != m_head)</span></span><br><span class="line">p_curr-&gt;next-&gt;prior = node;</span><br><span class="line">p_curr-&gt;next = node;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;        <span class="comment">//实际表长+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Db_Cir_Link_List&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前双循环链表为空，不能删除任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_willdel = p_curr-&gt;next; <span class="comment">//p_willdel指向待删除的节点</span></span><br><span class="line">Double_Node&lt;T&gt;* p_willdelNext = p_willdel-&gt;next; <span class="comment">//p_willdelNext指向待删除节点的下一个节点</span></span><br><span class="line">p_curr-&gt;next = p_willdel-&gt;next;<span class="comment">//第i-1个节点的next指针指向第i+1个节点</span></span><br><span class="line"><span class="comment">// 链表是循环的不需要进行  if (p_willdelNext != m_head)</span></span><br><span class="line">p_willdelNext-&gt;prior = p_curr;<span class="comment">//第i+1个节点的prior指针指向第i-1个节点</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length--;<span class="comment">//实际表长-1</span></span><br><span class="line"><span class="keyword">delete</span> p_willdel;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Db_Cir_Link_List&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前双循环链表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">e = p_curr-&gt;data;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按元素值查找其在双循环链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Db_Cir_Link_List&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双循环链表中第一次出现的位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双循环链表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出双循环链表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Db_Cir_Link_List&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* p = m_head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != m_head) <span class="comment">//这里采用while循环或者for循环书写都可以</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取双循环链表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span>  Db_Cir_Link_List&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双循环链表是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Db_Cir_Link_List&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_head-&gt;next == m_head) <span class="comment">//双循环链表为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对双循环链表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Db_Cir_Link_List&lt;T&gt;::~<span class="built_in">Db_Cir_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">Double_Node&lt;T&gt;* ptmp;</span><br><span class="line"><span class="keyword">while</span> (pnode != m_head) <span class="comment">//该循环负责释放数据节点</span></span><br><span class="line">&#123;</span><br><span class="line">ptmp = pnode;</span><br><span class="line">pnode = pnode-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> ptmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> m_head;    <span class="comment">//释放头结点</span></span><br><span class="line">m_head = <span class="literal">nullptr</span>; <span class="comment">//非必须</span></span><br><span class="line">m_length = <span class="number">0</span>;     <span class="comment">//非必须</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line"></span><br><span class="line">_nmsp1::Db_Cir_Link_List&lt;<span class="type">int</span>&gt;slinkobj;</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">slinkobj.<span class="built_in">ListDelete</span>(<span class="number">3</span>);</span><br><span class="line">slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">slinkobj.<span class="built_in">GetElem</span>(<span class="number">3</span>,a);</span><br><span class="line">cout &lt;&lt; slinkobj.<span class="built_in">ListLength</span>() &lt;&lt; endl;</span><br><span class="line">slinkobj.<span class="built_in">Empty</span>();</span><br><span class="line">slinkobj.<span class="built_in">LocateElem</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线性表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单循环链表的实现（c++）</title>
      <link href="/archives/b24eb132.html"/>
      <url>/archives/b24eb132.html</url>
      
        <content type="html"><![CDATA[<h1 id="单循环列表"><a href="#单循环列表" class="headerlink" title="单循环列表"></a>单循环列表</h1><ul><li>在单链表的基础上，将链表的最后一个结点的后继指针由指向nullptr修改为指向头结点。</li><li>优势在于只要给定了任意一个结点，都可以访问链表的所有结点</li><li>需要注意的是判断条件是头结点而不是nullptr</li></ul><h2 id="单循环列表的编程实现"><a href="#单循环列表的编程实现" class="headerlink" title="单循环列表的编程实现"></a>单循环列表的编程实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">T        data;  <span class="comment">//数据域，存放数据元素</span></span><br><span class="line">Node&lt;T&gt;* next;  <span class="comment">//指针域，指向下一个同类型（和本节点类型相同）节点</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单循环链表的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CirLinkList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CirLinkList</span>();      <span class="comment">//构造函数，参数可以有默认值</span></span><br><span class="line">~<span class="built_in">CirLinkList</span>();     <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">//在第i个位置插入指定元素e</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListInsertBack</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;              <span class="comment">//删除第i个位置的元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;           <span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;         <span class="comment">//按元素值查找其在单循环链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;                     <span class="comment">//输出单循环链表中的所有元素</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">ListLength</span><span class="params">()</span></span>;                   <span class="comment">//获取单循环链表的长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;                        <span class="comment">//判断单循环链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rear</span><span class="params">()</span></span>; <span class="comment">//检验尾指针的指向是否正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge_Link_list</span><span class="params">(CirLinkList&lt;T&gt; p1, CirLinkList&lt;T&gt; p2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;T&gt;* m_head;<span class="comment">//头指针</span></span><br><span class="line">Node&lt;T&gt;* m_rear;<span class="comment">//尾指针</span></span><br><span class="line"><span class="type">int</span> m_length;<span class="comment">//单循环链表长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数对单循环链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CirLinkList&lt;T&gt;::<span class="built_in">CirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_head = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">//先创建一个头结点</span></span><br><span class="line">m_head-&gt;next = m_head;<span class="comment">//指向头部（注意和单链表的差别）</span></span><br><span class="line">m_rear = m_head;<span class="comment">//尾指针初始化和头结点是一样的</span></span><br><span class="line">m_length = <span class="number">0</span>;<span class="comment">//头结点不计入单循环链表的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置（位置编号从1开始）插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断插入位置i是否合法，i的合法值应该是1到length+1之间</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是要插入尾指针之后</span></span><br><span class="line"><span class="comment">//如果i= 表长+1 ：代表就插入在尾处，相当于单链表的尾插法</span></span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">1</span> == m_length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ListInsertBack</span>(e);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = p_curr-&gt;next;</span><br><span class="line">p_curr-&gt;next = node;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;        <span class="comment">//实际表长+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速在尾部插入元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CirLinkList&lt;T&gt;::<span class="built_in">ListInsertBack</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = m_rear-&gt;next;</span><br><span class="line">m_rear-&gt;next = node;</span><br><span class="line">m_rear = node;</span><br><span class="line"><span class="keyword">if</span> (m_rear-&gt;next == m_head)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;尾部插入元素成功，更新尾指针成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">m_length++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前单循环链表为空，不能删除任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)<span class="comment">//用于定位</span></span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;T&gt;* p_willdel = p_curr-&gt;next;<span class="comment">//p_willdel指向待删除的节点</span></span><br><span class="line">p_curr-&gt;next = p_willdel-&gt;next;<span class="comment">//第i-1个节点的next指针指向第i+1个节点</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length--;<span class="comment">//实际表长-1</span></span><br><span class="line"><span class="keyword">delete</span> p_willdel;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前单循环链表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">e = p_curr-&gt;data;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按元素值查找其在单循环链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> CirLinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单循环链表中第一次出现的位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单循环链表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出单循环链表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> CirLinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* p = m_head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != m_head)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单循环链表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span>  CirLinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对单循环链表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CirLinkList&lt;T&gt;::~<span class="built_in">CirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">Node&lt;T&gt;* ptmp;</span><br><span class="line"><span class="keyword">while</span> (pnode != m_head)   <span class="comment">//该循环负责释放数据节点（注意循环的条件）</span></span><br><span class="line">&#123;</span><br><span class="line">ptmp = pnode;</span><br><span class="line"></span><br><span class="line">pnode = pnode-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> ptmp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> m_head;    <span class="comment">//释放头结点</span></span><br><span class="line">m_head = <span class="literal">nullptr</span>;<span class="comment">//非必须</span></span><br><span class="line">m_length = <span class="number">0</span>;     <span class="comment">//非必须</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CirLinkList&lt;T&gt;::<span class="built_in">rear</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; 链表最后一个元素为&quot;</span> &lt;&lt; m_rear-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CirLinkList&lt;T&gt;::<span class="built_in">Merge_Link_list</span>(CirLinkList&lt;T&gt;p1, CirLinkList&lt;T&gt;p2)<span class="comment">//合并两个单循环链表</span></span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* p1_rear = p1.m_rear;</span><br><span class="line">Node&lt;T&gt;* p1head = p1_rear-&gt;next;</span><br><span class="line">Node&lt;T&gt;* p2_rear = p2.m_rear;</span><br><span class="line">Node&lt;T&gt;* p2head = p2_rear-&gt;next;</span><br><span class="line"></span><br><span class="line">p1_rear-&gt;next = p2_rear-&gt;next-&gt;next;</span><br><span class="line">p2_rear-&gt;next = p1head;</span><br><span class="line"></span><br><span class="line">p1_rear = p2_rear;</span><br><span class="line"><span class="comment">//delete p2head;</span></span><br><span class="line">p1.m_length += p2.m_length;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;合并链表&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);<span class="comment">//程序退出时检测内存泄漏并显示到“输出”窗口</span></span><br><span class="line"></span><br><span class="line">_nmsp1::CirLinkList&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">_nmsp1::CirLinkList&lt;<span class="type">int</span>&gt; slinkobj1;</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">slinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">slinkobj.<span class="built_in">rear</span>();</span><br><span class="line"></span><br><span class="line">slinkobj1.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">slinkobj1.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">slinkobj1.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">3000</span>);</span><br><span class="line">slinkobj1.<span class="built_in">ListInsert</span>(<span class="number">4</span>, <span class="number">4000</span>);</span><br><span class="line">slinkobj1.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">slinkobj.<span class="built_in">Merge_Link_list</span>(slinkobj, slinkobj1);</span><br><span class="line">slinkobj1.<span class="built_in">DispList</span>();</span><br><span class="line">slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//slinkobj.ListInsertBack(1000);</span></span><br><span class="line"><span class="comment">//slinkobj.DispList();</span></span><br><span class="line"><span class="comment">//slinkobj.rear();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//slinkobj.ListDelete(4);</span></span><br><span class="line"><span class="comment">//slinkobj.rear();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int eval = 0;</span></span><br><span class="line"><span class="comment">//slinkobj.GetElem(3, eval); //如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line"><span class="comment">//int findvalue = 100; //在单循环链表中要找的元素值</span></span><br><span class="line"><span class="comment">//slinkobj.LocateElem(findvalue);</span></span><br><span class="line"><span class="comment">//slinkobj.DispList();</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;单循环链表的长度为：&quot; &lt;&lt; slinkobj.ListLength() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：以上代码不是完全正确，在合并两个单链表的功能报错，后续解决。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线性表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双链表的实现（c++）</title>
      <link href="/archives/68c04350.html"/>
      <url>/archives/68c04350.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是双链表"><a href="#什么是双链表" class="headerlink" title="什么是双链表"></a>什么是双链表</h1><ul><li>单链表的缺点<ul><li>如果要寻找单链表中某个已知结点的前趋结点会比较繁琐，必须去从链表头出发开始寻找，这样也就导致算法的平均情况时间复杂度O（n）。</li></ul></li><li>在单链表的基础上，增加一个用于指向前趋节点的指针。也就是说双链表是由单链表衍生出来的链表结构。</li><li>双链表的结点中有两个指针prior和next，分别指向前驱结点和后继结点。</li></ul><hr><h1 id="双链表的数据成员"><a href="#双链表的数据成员" class="headerlink" title="双链表的数据成员"></a>双链表的数据成员</h1><ul><li>一个结点包含一个数据域和两个指针域（前趋指针，后继指针）</li><li>前趋指针指向该节点的前一个结点</li><li>后继指针指向该结点的后一个结点（尾结点除外，尾结点的后继指针next为nullptr</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双链表中每个结点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Double_Node</span></span><br><span class="line">&#123;</span><br><span class="line">T data;</span><br><span class="line">Double_Node&lt;T&gt;* prior;</span><br><span class="line">Double_Node&lt;T&gt;* next;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="双链表的基本操作"><a href="#双链表的基本操作" class="headerlink" title="双链表的基本操作"></a>双链表的基本操作</h1><ul><li><p>双链表的类的定义和成员函数方法的设计</p><ul><li>构造函数</li><li>析构函数</li><li>在第i个位置插入结点</li><li>删除第i个位置的元素</li><li>获取第i个位置的元素</li><li>获取值为e的在链表中第一次出现的位置</li><li>遍历输出所有元素</li><li>获取双链表的长度</li><li>判断链表是否为空</li></ul><hr></li></ul><h1 id="双链表的编程实现"><a href="#双链表的编程实现" class="headerlink" title="双链表的编程实现"></a>双链表的编程实现</h1><h2 id="双链表类的定义"><a href="#双链表类的定义" class="headerlink" title="双链表类的定义"></a>双链表类的定义</h2><ul><li>和单链表类似</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双链表的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Double_Link_List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Double_Link_List</span>();<span class="comment">//构造函数</span></span><br><span class="line">~<span class="built_in">Double_Link_List</span>();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Double_Link_List_insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//在第i个位置插入</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Double_Link_List_delete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//删除第i个位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Get_Elem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;<span class="comment">//获取第i个位置的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locate_Elem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//获取值为e的第一个出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display_Double_Link_List</span><span class="params">()</span></span>;<span class="comment">//遍历输出所有元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Double_Link_List_length</span><span class="params">()</span></span>;<span class="comment">//获取双链表的长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;<span class="comment">//判断链表是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Double_Node&lt;T&gt;* m_head;<span class="comment">//头结点</span></span><br><span class="line"><span class="type">int</span> m_length;<span class="comment">//表长</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="构造函数并且进行初始化"><a href="#构造函数并且进行初始化" class="headerlink" title="构造函数并且进行初始化"></a>构造函数并且进行初始化</h2><ul><li>头结点的前趋指针永远为空</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_head = <span class="keyword">new</span> Double_Node&lt;T&gt;;</span><br><span class="line">m_head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">m_head-&gt;prior = <span class="literal">nullptr</span>;<span class="comment">//头结点永远为空</span></span><br><span class="line">m_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="在第i个位置插入结点"><a href="#在第i个位置插入结点" class="headerlink" title="在第i个位置插入结点"></a>在第i个位置插入结点</h2><ul><li>首先判断位置<strong>i</strong>是否合法</li><li>遍历结点找到插入位置i的前一个位置</li><li>进行插入结点顺序如图所示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chuannihaoa/picog/imageimage-20221031154341742.png" alt="插入结点"></p><ul><li>表长更新</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List_insert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断插入位置i是否合法，i的合法值应该是1到length+1之间</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;<span class="comment">//用于找到定位应插入的位置的前一个位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* node = <span class="keyword">new</span> Double_Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = p_curr-&gt;next;</span><br><span class="line">node-&gt;prior = p_curr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果插入的位置是尾结点，就没有后续结点的前趋指针指向新结点，故跳过；</span></span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p_curr-&gt;next-&gt;prior = node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">p_curr-&gt;next = node;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="删除第i个位置的元素"><a href="#删除第i个位置的元素" class="headerlink" title="删除第i个位置的元素"></a>删除第i个位置的元素</h2><ul><li>判断表长是否为空</li><li>判断位置i是否合法</li><li>找到删除结点的前一个结点</li><li>进行删除结点顺序如图所示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chuannihaoa/picog/imageimage-20221031155617849.png"></p><ul><li>更新表长</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List_delete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前双链表为空，不能删除任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* will_delete = p_curr-&gt;next<span class="comment">//记录将要删除的结点</span></span><br><span class="line">Double_Node&lt;T&gt;* will_delete_Next = will_delete-&gt;next;<span class="comment">//记录删除结点的下一个位置</span></span><br><span class="line">p_curr-&gt;next = will_delete-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (will_delete_Next != <span class="literal">nullptr</span>)<span class="comment">//删除结点是尾结点故跳过</span></span><br><span class="line">&#123;</span><br><span class="line">will_delete_Next-&gt;prior = p_curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; will_delete-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length--;       <span class="comment">//实际表长-1</span></span><br><span class="line"><span class="keyword">delete</span> will_delete;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="获得第i个位置的元素值"><a href="#获得第i个位置的元素值" class="headerlink" title="获得第i个位置的元素值"></a>获得第i个位置的元素值</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Get_Elem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前双链表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">e = p_curr-&gt;data;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="按元素值查找其在双链表中第一次出现的位置"><a href="#按元素值查找其在双链表中第一次出现的位置" class="headerlink" title="按元素值查找其在双链表中第一次出现的位置"></a>按元素值查找其在双链表中第一次出现的位置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按元素值查找其在双链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Double_Link_List&lt;T&gt;::<span class="built_in">Locate_Elem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双链表中第一次出现的位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双链表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="获取双链表的长度"><a href="#获取双链表的长度" class="headerlink" title="获取双链表的长度"></a>获取双链表的长度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取双链表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span>  Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List_length</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="判断双链表是否为空"><a href="#判断双链表是否为空" class="headerlink" title="判断双链表是否为空"></a>判断双链表是否为空</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断双链表是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_head-&gt;next == <span class="literal">nullptr</span>) <span class="comment">//双链表为空（如果是不带头结点的双链表则用if(m_head == nullptr）来判断是否为空）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="遍历输出所有元素"><a href="#遍历输出所有元素" class="headerlink" title="遍历输出所有元素"></a>遍历输出所有元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Double_Link_List&lt;T&gt;::<span class="built_in">Display_Double_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* p = m_head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>) <span class="comment">//这里采用while循环或者for循环书写都可以</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过析构函数对双链表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Double_Link_List&lt;T&gt;::~<span class="built_in">Double_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">Double_Node&lt;T&gt;* ptmp;</span><br><span class="line"><span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)<span class="comment">//该循环负责释放数据节点</span></span><br><span class="line">&#123;</span><br><span class="line">ptmp = pnode;</span><br><span class="line">pnode = pnode-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> ptmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> m_head;    <span class="comment">//释放头结点</span></span><br><span class="line">m_head = <span class="literal">nullptr</span>; <span class="comment">//非必须</span></span><br><span class="line">m_length = <span class="number">0</span>;     <span class="comment">//非必须</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>在单链表中，如果已知结点的情况下，寻找后继结点的时间复杂度O(1)，如果想要找前趋结点就必须从链表头开始往后遍历，所以最坏情况时间复杂度O(n)；双链表具有前趋指针，找到已知结点的前面一个结点的时间复杂度为O（1），大大提高了寻找效率；</li><li>双链表的某结点p的前趋结点的后继指针以及后继结点的前趋指针代表的都是p结点本身</li><li>因双链表添加了前趋指针，要额外消耗存储空间。</li></ul><h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _nmsp</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表中每个结点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Double_Node</span></span><br><span class="line">&#123;</span><br><span class="line">T data;</span><br><span class="line">Double_Node&lt;T&gt;* prior;</span><br><span class="line">Double_Node&lt;T&gt;* next;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Double_Link_List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Double_Link_List</span>();<span class="comment">//构造函数</span></span><br><span class="line">~<span class="built_in">Double_Link_List</span>();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Double_Link_List_insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//在第i个位置插入</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Double_Link_List_delete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//删除第i个位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Get_Elem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;<span class="comment">//获取第i个位置的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locate_Elem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//获取值为e的第一个出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display_Double_Link_List</span><span class="params">()</span></span>;<span class="comment">//遍历输出所有元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Double_Link_List_length</span><span class="params">()</span></span>;<span class="comment">//获取双链表的长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;<span class="comment">//判断链表是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Double_Node&lt;T&gt;* m_head;</span><br><span class="line"><span class="type">int</span> m_length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_head = <span class="keyword">new</span> Double_Node&lt;T&gt;;</span><br><span class="line">m_head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">m_head-&gt;prior = <span class="literal">nullptr</span>;</span><br><span class="line">m_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List_insert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断插入位置i是否合法，i的合法值应该是1到length+1之间</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;<span class="comment">//用于找到定位应插入的位置的前一个位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* node = <span class="keyword">new</span> Double_Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = p_curr-&gt;next;</span><br><span class="line">node-&gt;prior = p_curr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果插入的位置是尾结点，就没有后续结点的前趋指针指向新结点，故跳过；</span></span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p_curr-&gt;next-&gt;prior = node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">p_curr-&gt;next = node;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List_delete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前双链表为空，不能删除任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* will_delete = p_curr-&gt;next<span class="comment">//记录将要删除的结点</span></span><br><span class="line">Double_Node&lt;T&gt;* will_delete_Next = will_delete-&gt;next;<span class="comment">//记录删除结点的下一个位置</span></span><br><span class="line">p_curr-&gt;next = will_delete-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (will_delete_Next != <span class="literal">nullptr</span>)<span class="comment">//删除结点是尾结点故跳过</span></span><br><span class="line">&#123;</span><br><span class="line">will_delete_Next-&gt;prior = p_curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; will_delete-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length--;       <span class="comment">//实际表长-1</span></span><br><span class="line"><span class="keyword">delete</span> will_delete;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Get_Elem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前双链表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">e = p_curr-&gt;data;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按元素值查找其在双链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Double_Link_List&lt;T&gt;::<span class="built_in">Locate_Elem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双链表中第一次出现的位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双链表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取双链表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span>  Double_Link_List&lt;T&gt;::<span class="built_in">Double_Link_List_length</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双链表是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Double_Link_List&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_head-&gt;next == <span class="literal">nullptr</span>) <span class="comment">//双链表为空（如果是不带头结点的双链表则用if(m_head == nullptr）来判断是否为空）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对双链表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Double_Link_List&lt;T&gt;::~<span class="built_in">Double_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">Double_Node&lt;T&gt;* ptmp;</span><br><span class="line"><span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)<span class="comment">//该循环负责释放数据节点</span></span><br><span class="line">&#123;</span><br><span class="line">ptmp = pnode;</span><br><span class="line">pnode = pnode-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> ptmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> m_head;    <span class="comment">//释放头结点</span></span><br><span class="line">m_head = <span class="literal">nullptr</span>; <span class="comment">//非必须</span></span><br><span class="line">m_length = <span class="number">0</span>;     <span class="comment">//非必须</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Double_Link_List&lt;T&gt;::<span class="built_in">Display_Double_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">Double_Node&lt;T&gt;* p = m_head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>) <span class="comment">//这里采用while循环或者for循环书写都可以</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line">_nmsp::Double_Link_List&lt;<span class="type">int</span>&gt; Creat_D_L_List;</span><br><span class="line">Creat_D_L_List.<span class="built_in">Double_Link_List_insert</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">Creat_D_L_List.<span class="built_in">Double_Link_List_insert</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">Creat_D_L_List.<span class="built_in">Double_Link_List_insert</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">Creat_D_L_List.<span class="built_in">Display_Double_Link_List</span>();</span><br><span class="line">Creat_D_L_List.<span class="built_in">Double_Link_List_length</span>();</span><br><span class="line"></span><br><span class="line">Creat_D_L_List.<span class="built_in">Double_Link_List_delete</span>(<span class="number">1</span>);</span><br><span class="line">Creat_D_L_List.<span class="built_in">Display_Double_Link_List</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线性表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的实现（c++）</title>
      <link href="/archives/ac1d2ce8.html"/>
      <url>/archives/ac1d2ce8.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是单链表"><a href="#什么是单链表" class="headerlink" title="什么是单链表"></a>什么是单链表</h1><ul><li>我们知道顺序表的最大的缺点是插入和删除操作可能移动大量的元素，会导致程序的执行效率很低。导致程序低效的原因就是顺序表的元素必须连续且不能有间隙，建立一个顺序表的时候需要在内存中很大一片连续空的空间进行创造。</li><li>线性表的链式存储不需要使用连续的内存空间，链式存储是是通过“链”也就是指针的指向来建立各个相邻元素的关系，使其保证元素之间像一条线一样按顺序排列。<ul><li>优点：我们在插入和删除元素的时候，就不需要进行大量的数据元素的迁移，只需改变修改元素的（结点）的指针的指向。</li><li>缺点：结点结构比顺序表的结点结构要复杂一点。</li></ul></li></ul><hr><h1 id="单链表的数据成员"><a href="#单链表的数据成员" class="headerlink" title="单链表的数据成员"></a>单链表的数据成员</h1><ul><li>一个结点包含一个数据域和一个指针域（指针的内容是指向下一个结点的地址）</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">T data;<span class="comment">//数据域</span></span><br><span class="line">Node&lt;T&gt;* next;<span class="comment">//指针域</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h1><ul><li><p>单链表的类的定义和设计</p><ul><li><p>构造函数</p></li><li><p>析构函数</p></li><li><p>插入元素</p><ul><li>在第i个位置插入元素</li><li>快速在尾部插入元素</li><li>在已知结点之前插入元素</li></ul></li><li><p>删除第i个位置的元素</p></li><li><p>获取元素</p></li><li><p>按元素值查找第一次出现的位置</p></li><li><p>展示链表所有元素</p></li><li><p>获取链表的长度</p></li><li><p>判断链表是否为空</p></li><li><p>翻转链表</p></li><li><p>查看尾指针</p></li></ul></li></ul><hr><h1 id="单链表的编程实现"><a href="#单链表的编程实现" class="headerlink" title="单链表的编程实现"></a>单链表的编程实现</h1><h2 id="单链表类的定义"><a href="#单链表类的定义" class="headerlink" title="单链表类的定义"></a>单链表类的定义</h2><p>(这个版本是包含了尾指针的)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义单链表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Link_List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Link_List</span>();  <span class="comment">//构造函数</span></span><br><span class="line">~<span class="built_in">Link_List</span>();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="comment">//按位置插入元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//在第i个位置插入元素</span></span><br><span class="line"><span class="comment">//快速在尾部插入元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Link_List_Insert_Back</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="comment">//在已知的结点之前插入元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Prior_Insert_Node</span><span class="params">(<span class="type">const</span> T&amp; e, Node&lt;T&gt;*purr )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Delete</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line"><span class="function">T <span class="title">Get_Link_List_Elem</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//获取第i个元素的值</span></span><br><span class="line"><span class="function">Node&lt;T&gt;* <span class="title">Get_Link_List_point</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//获取第i个元素的指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按照元素值查找链表中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locate_Link_List_Elem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出链表所有的元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display_Link_List</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取链表的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Link_List_length</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse_Link_List</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看尾指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;T&gt;* m_head;<span class="comment">//单链表的头指针</span></span><br><span class="line"><span class="type">int</span> m_length;<span class="comment">//单链表的实际长度</span></span><br><span class="line"> Node&lt;T&gt;* m_rear ;<span class="comment">//单链表的尾指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="1-构造函数（初始化）"><a href="#1-构造函数（初始化）" class="headerlink" title="1)构造函数（初始化）"></a>1)构造函数（初始化）</h2><ul><li>首先会开辟一个内存存储结点，并让头指针指向它</li><li>因为是第一个结点，又是链表，头结点的指针域暂时指向nullptr</li><li>记录链表长度（头结点不算入）</li><li>尾指针指向链表尾部，初始化指向头结点（尾指针永远指向尾部）</li><li>注意事项：链表只要<strong>进行结构的变化</strong>（比如说进行删除结点，插入结点）一定要<strong>及时更新链表的长度和尾指针的指向</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Link_List&lt;T&gt;::<span class="built_in">Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_head = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">//头指针初始化并指向开辟一个内存</span></span><br><span class="line">m_head-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//头结点是链表的第0个结点，此时也是尾结点</span></span><br><span class="line">m_length = <span class="number">0</span>;<span class="comment">//头结点不算入实际长度</span></span><br><span class="line">m_rear = m_head;<span class="comment">//尾指针指向尾结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-析构函数"><a href="#2-析构函数" class="headerlink" title="2)析构函数"></a>2)析构函数</h2><ul><li>对链表中每个结点都必须进行释放</li><li>释放的同时，表的长度更新为0</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//析构函数进行释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Link_List&lt;T&gt;::~<span class="built_in">Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对链表中的每个结点都需要进行释放</span></span><br><span class="line">Node&lt;T&gt;* pnode = m_head-&gt;next;<span class="comment">//记录下一个结点的指向</span></span><br><span class="line">Node&lt;T&gt;* ptemp;<span class="comment">//记录释放的结点</span></span><br><span class="line"><span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">ptemp = pnode;</span><br><span class="line">pnode = pnode-&gt;next;<span class="comment">//更新结点</span></span><br><span class="line"><span class="keyword">delete</span> ptemp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> m_head;</span><br><span class="line">m_head = <span class="literal">nullptr</span>;<span class="comment">//非必须，建议</span></span><br><span class="line">m_rear = <span class="literal">nullptr</span>;<span class="comment">//非必须，建议</span></span><br><span class="line">m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3)插入元素"></a>3)插入元素</h2><ul><li>头部插入，尾部插入，中间元素插入均可适用  **在第i个位置插入元素 **这个版本</li><li><strong>快速在尾部插入元素</strong>  与  <strong>在第i个位置插入元素</strong>的尾部插入是一样的，只是少了个形参</li><li><strong>在已知的结点之前插入元素</strong>   设计这个目的是时间复杂度O（1），就不需要去遍历单链表的所有元素</li><li>上述的头部插入时间复杂度为O（1）；尾部插入是因为设计了一个尾指针永远指向尾部结点，则尾部插入也是O（1）；中间插入结点 需要去遍历链表找到该位置的前一个结点，则时间复杂度为O（n）</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="comment">//在第i个位置插入元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="comment">//快速在尾部插入元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Link_List_Insert_Back</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="comment">//在已知的结点之前插入元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Prior_Insert_Node</span><span class="params">(<span class="type">const</span> T&amp; e, Node&lt;T&gt;*purr )</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="4-在第i个位置插入元素"><a href="#4-在第i个位置插入元素" class="headerlink" title="4)在第i个位置插入元素"></a>4)在第i个位置插入元素</h3><ul><li>判断位置i是否合法</li><li>判断第i个位置是否为单链表尾部，是则调用  <strong>快速在尾部插入元素</strong></li><li>如果i &#x3D;1相当于头插法</li><li>更新表长；如果是尾部插入，在  <strong>快速在尾部插入元素</strong>  里面<strong>已经更新</strong>了尾指针的指向和单链表的表长；<strong>不是尾部插入只需要更新单链表长</strong></li><li>i&#x3D; 1，时间复杂度为O（1）；尾部插入，时间复杂度为O（1）；其他位置插入的平均时间复杂度为O（n)</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在第i个位置插入元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Insert</span>(<span class="type">int</span> i ,<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">i</span>&lt;<span class="number">1</span> || i&gt;(m_length + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span></span><br><span class="line">&lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是要插入尾指针之后</span></span><br><span class="line"><span class="comment">//如果i= 表长+1 ：代表就插入在尾处，相当于单链表的尾插法</span></span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">1</span> == m_length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Link_List_Insert_Back</span>( e);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;<span class="comment">//新建一个指针的目的是为指向第（i-1)的结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始定位第i-1位置的结点</span></span><br><span class="line"><span class="comment">//如果i=1，直接跳过for循环，在头结点下一个位置插入，相当于单链表的头插法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">//开辟一个新的内存存储要插入的结点</span></span><br><span class="line">node-&gt;data = e;<span class="comment">//存储数据域</span></span><br><span class="line">node-&gt;next = p_curr-&gt;next;<span class="comment">//以下两步指针域指向赋值顺序不可颠倒</span></span><br><span class="line">p_curr-&gt;next = node;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;<span class="comment">//更新表长</span></span><br></pre></td></tr></table></figure><h3 id="5-快速在尾部插入元素"><a href="#5-快速在尾部插入元素" class="headerlink" title="5)快速在尾部插入元素"></a>5)快速在尾部插入元素</h3><ul><li>核心步骤都是一样的</li><li>时间复杂度为O（1）</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Insert_Back</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">//存储新节点</span></span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = m_rear-&gt;next;</span><br><span class="line">m_rear-&gt;next = node;</span><br><span class="line">m_rear = node;<span class="comment">//更新尾指针</span></span><br><span class="line"><span class="keyword">if</span> (m_rear-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;尾部插入元素成功，更新尾指针成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">m_length++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-在已知结点之前插入元素"><a href="#6-在已知结点之前插入元素" class="headerlink" title="6)在已知结点之前插入元素"></a>6)在已知结点之前插入元素</h3><ul><li>先判断结点是否是尾结点</li><li>先将这个新结点插入到已知结点之后</li><li>然后将其已知结点和新结点的数据域进行交换</li><li>时间复杂度为O(1)</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//已知结点插入元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T &gt; </span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Prior_Insert_Node</span>(<span class="type">const</span> T&amp; e, Node&lt;T&gt;* purr )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//链表末尾插入（防止已知结点是尾结点）</span></span><br><span class="line"><span class="keyword">if</span> (purr-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Link_List_Insert_Back</span>( e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在purr结点之前插入新结点</span></span><br><span class="line"><span class="comment">//先将新结点插入到已知结点之后</span></span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = purr-&gt;next;</span><br><span class="line">purr-&gt;next = node;</span><br><span class="line"><span class="built_in">Display_Link_List</span>();</span><br><span class="line"><span class="comment">//交换数据域</span></span><br><span class="line">T temp = node-&gt;data;</span><br><span class="line">node-&gt;data = purr-&gt;data;</span><br><span class="line">purr-&gt;data = temp;</span><br><span class="line">m_length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序是便于获得某个元素的指向来作为上一个程序的形参来进行检验的</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得第i个位置的元素,返回指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Node&lt;T&gt;* Link_List&lt;T&gt;:: <span class="built_in">Get_Link_List_point</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p_curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="7-删除第i个位置的元素"><a href="#7-删除第i个位置的元素" class="headerlink" title="7)删除第i个位置的元素"></a>7)删除第i个位置的元素</h2><ul><li><p>判断链表是否为空</p></li><li><p>判断位置i是否为链表的合法位置</p></li><li><p>遍历链表找第i-1个位置的元素</p><ul><li>如果 i &#x3D;表长，则说明删除的结点是尾结点，则需要更新尾指针，和前一个结点的指针域赋值为nullptr</li></ul></li><li><p>更新表长</p></li><li><p>释放要删除的结点</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Delete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (m_length == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;链表为空不可删除元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断删除是否合法位置</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> </span><br><span class="line">&lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到第（i-1）位置结点的指向</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;  <span class="comment">//指向第i-1位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针域指向操作</span></span><br><span class="line">Node&lt;T&gt;* will_delete = p_curr-&gt;next;  <span class="comment">//will_delete指向第i个位置结点</span></span><br><span class="line">p_curr-&gt;next = will_delete-&gt;next;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> </span><br><span class="line">&lt;&lt; will_delete-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新尾指针</span></span><br><span class="line"><span class="keyword">if</span> (i == m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;说明删除的是尾结点,需要更新尾指针&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_rear = p_curr;</span><br><span class="line"><span class="keyword">if</span> (m_rear-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;更新尾结点成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m_length--;<span class="comment">//表长-1</span></span><br><span class="line"><span class="comment">//释放删除的结点</span></span><br><span class="line"><span class="keyword">delete</span> will_delete;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="8-获取元素"><a href="#8-获取元素" class="headerlink" title="8)获取元素"></a>8)获取元素</h2><ul><li>判断链表是否为空</li><li>判断位置i是否为链表的合法位置</li><li>遍历寻找</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得第i个位置的元素,返回值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Link_List&lt;T&gt;::<span class="built_in">Get_Link_List_Elem</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前单链表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span></span><br><span class="line">&lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)<span class="comment">//这里是i不是i-1</span></span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> </span><br><span class="line">&lt;&lt; p_curr-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> p_curr-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="9-按元素值查找第一次出现的位置"><a href="#9-按元素值查找第一次出现的位置" class="headerlink" title="9)按元素值查找第一次出现的位置"></a>9)按元素值查找第一次出现的位置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照元素值查找链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Link_List&lt;T&gt;::<span class="built_in">Locate_Link_List_Elem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; i++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;data == e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单链表中第一次出现的位置为&quot;</span> </span><br><span class="line">&lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单链表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="10-展示链表所有元素"><a href="#10-展示链表所有元素" class="headerlink" title="10)展示链表所有元素"></a>10)展示链表所有元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出链表所有的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">Display_Link_List</span>() </span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* p = m_head;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;单链表所有元素展示：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="11-获取链表的长度"><a href="#11-获取链表的长度" class="headerlink" title="11)获取链表的长度"></a>11)获取链表的长度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取链表的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_length</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-判断链表是否为空"><a href="#12-判断链表是否为空" class="headerlink" title="12)判断链表是否为空"></a>12)判断链表是否为空</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;:: <span class="built_in">Link_List_Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_head-&gt;next == <span class="literal">nullptr</span>) <span class="comment">//单链表为空（如果是不带头结点的单</span></span><br><span class="line"><span class="comment">//链表则用if(m_head == nullptr）来判断是否为空）</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;单链表不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="13-翻转链表"><a href="#13-翻转链表" class="headerlink" title="13)翻转链表"></a>13)翻转链表</h2><p>以a0 a1 a2 a3 a4为例，其中a0为头结点</p><ul><li><p>判断单链表是否为空或者只有一个元素</p></li><li><p>将头结点和第二个结点作为一个整体（a0和a1），翻转过后a1作为最后一个元素，则a1的指针域为nullptr，尾指针也要更新为a1</p></li><li><p>后续只要改变的a2元素的指针域的指向（和头插法的步骤一致），同时也要更新要处理的结点也就是a3</p><p><img src="https://cdn.jsdelivr.net/gh/chuannihaoa/picog/image20221028125057.png" alt="反转链表"></p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 翻转链表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">Reverse_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果没有顺序表中没有元素或者只有一个元素，那么就不用做任何操作</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p2 = m_head-&gt;next-&gt;next;<span class="comment">// 获取指向第二个结点的指针域</span></span><br><span class="line">m_head-&gt;next-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//将第一个结点的指针域赋值为空（作为最后一个结点）</span></span><br><span class="line">m_rear = m_head-&gt;next;<span class="comment">//更新尾指针</span></span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr;</span><br><span class="line"><span class="comment">//只要改变第二个结点的指针域指向，便可改变顺序</span></span><br><span class="line"><span class="comment">//具体步骤和头插法一致</span></span><br><span class="line"><span class="keyword">while</span> (p2 != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p2;<span class="comment">//当前（假设a2)赋给p_curr指针进行插入操作</span></span><br><span class="line">p2 = p2 -&gt; next;<span class="comment">//更新结点</span></span><br><span class="line"> </span><br><span class="line">p_curr-&gt;next = m_head-&gt;next;</span><br><span class="line">m_head-&gt;next = p_curr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-查看尾指针"><a href="#14-查看尾指针" class="headerlink" title="14)查看尾指针"></a>14)查看尾指针</h2><ul><li>主要用于查看是否正确</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">rear</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; 链表最后一个元素为&quot;</span>&lt;&lt;m_rear-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);<span class="comment">//程序退出时检测内存泄漏并显示到“输出”窗口</span></span><br><span class="line">_nmsp::Link_List&lt;<span class="type">int</span>&gt; Creat_link;</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> length = Creat_link.<span class="built_in">Link_List_length</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;单链表长度为&quot;</span> &lt;&lt; length &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Reverse_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Get_Link_List_Elem</span>(<span class="number">3</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Empty</span>();</span><br><span class="line">Creat_link.<span class="built_in">Locate_Link_List_Elem</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Link_List_Delete</span>(<span class="number">6</span>);</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line"></span><br><span class="line">_nmsp::Node&lt;<span class="type">int</span>&gt; * node = Creat_link.<span class="built_in">Get_Link_List_point</span>(<span class="number">4</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Prior_Insert_Node</span>(<span class="number">1000</span>, node);</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>并不需要大片的连续存储空间来存放数据元素，扩容很方便</p></li><li><p>插入和删除结点相对于顺序表来说很方便，平均时间复杂度为O（n），如果是头部插入和尾部插入和在已知结点插入，那么时间复杂度就为O（1），这也就说明链表更适合插入，删除的频繁操作</p></li><li><p>存放后后继指针要额外的消耗存储空间，体现了利用空间来换时间来提高算法效率的编程思想</p></li><li><p>单链表也有一个很大的弊端，它的内存空间不连续，无法实现随机访问单链表中的元素，如果要访问某个结点只能从链表中第一个结点开始往下进行遍历，单链表的主要时间都花在了遍历元素的方面，平均时间复杂度为O（n).</p></li></ul><hr><h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> _nmsp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">T data;</span><br><span class="line">Node&lt;T&gt;* next;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义单链表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Link_List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Link_List</span>();  <span class="comment">//构造函数</span></span><br><span class="line">~<span class="built_in">Link_List</span>();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="comment">//按位置插入元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//在第i个位置插入元素</span></span><br><span class="line"><span class="comment">//快速在尾部插入元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Link_List_Insert_Back</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="comment">//在已知的结点之前插入元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Prior_Insert_Node</span><span class="params">(<span class="type">const</span> T&amp; e, Node&lt;T&gt;* purr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Delete</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line"><span class="function">T <span class="title">Get_Link_List_Elem</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//获取第i个元素的值</span></span><br><span class="line"><span class="function">Node&lt;T&gt;* <span class="title">Get_Link_List_point</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//获取第i个元素的指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按照元素值查找链表中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locate_Link_List_Elem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出链表所有的元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display_Link_List</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取链表的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Link_List_length</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Link_List_Empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse_Link_List</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看尾指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node&lt;T&gt;* m_head;<span class="comment">//单链表的头指针</span></span><br><span class="line"><span class="type">int</span> m_length;<span class="comment">//单链表的实际长度</span></span><br><span class="line">Node&lt;T&gt;* m_rear;<span class="comment">//单链表的尾指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Link_List&lt;T&gt;::<span class="built_in">Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_head = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">//头指针初始化并指向开辟一个内存</span></span><br><span class="line">m_head-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//头结点是链表的第0个结点，此时也是尾结点</span></span><br><span class="line">m_length = <span class="number">0</span>;<span class="comment">//头结点不算入实际长度</span></span><br><span class="line">m_rear = m_head;<span class="comment">//尾指针指向尾结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第i个位置插入元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Insert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">i</span>&lt;<span class="number">1</span> || i&gt;(m_length + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span></span><br><span class="line">&lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是要插入尾指针之后</span></span><br><span class="line"><span class="comment">// 如果i= 表长+1 ：代表就插入在尾处，相当于单链表的尾插法</span></span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">1</span> == m_length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Link_List_Insert_Back</span>(e);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;<span class="comment">//新建一个指针的目的是为指向第（i-1)的结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始定位第i-1位置的结点</span></span><br><span class="line"><span class="comment">//如果i=1，直接跳过for循环，在头结点下一个位置插入，相当于单链表的头插法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">//开辟一个新的内存存储要插入的结点</span></span><br><span class="line">node-&gt;data = e;<span class="comment">//存储数据域</span></span><br><span class="line">node-&gt;next = p_curr-&gt;next;<span class="comment">//以下两步指针域指向赋值顺序不可颠倒</span></span><br><span class="line">p_curr-&gt;next = node;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;<span class="comment">//更新表长</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速在尾部插入元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Insert_Back</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = m_rear-&gt;next;</span><br><span class="line">m_rear-&gt;next = node;</span><br><span class="line">m_rear = node;</span><br><span class="line"><span class="keyword">if</span> (m_rear-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;尾部插入元素成功，更新尾指针成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">m_length++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已知结点插入元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Prior_Insert_Node</span>(<span class="type">const</span> T&amp; e, Node&lt;T&gt;* purr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 链表末尾插入（防止已知结点是尾结点）</span></span><br><span class="line"><span class="keyword">if</span> (purr-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Link_List_Insert_Back</span>(e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在purr结点之前插入新结点</span></span><br><span class="line">Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">node-&gt;data = e;</span><br><span class="line">node-&gt;next = purr-&gt;next;</span><br><span class="line">purr-&gt;next = node;</span><br><span class="line"><span class="built_in">Display_Link_List</span>();</span><br><span class="line"><span class="comment">// 交换数据域</span></span><br><span class="line">T temp = node-&gt;data;</span><br><span class="line">node-&gt;data = purr-&gt;data;</span><br><span class="line">purr-&gt;data = temp;</span><br><span class="line">m_length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Delete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (m_length == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;链表为空不可删除元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断删除是否合法位置</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span></span><br><span class="line">&lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第（i-1）位置结点的指向</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;  <span class="comment">//指向第i-1位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针域指向操作</span></span><br><span class="line">Node&lt;T&gt;* will_delete = p_curr-&gt;next;  <span class="comment">//will_delete指向第i个位置结点</span></span><br><span class="line">p_curr-&gt;next = will_delete-&gt;next;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span></span><br><span class="line">&lt;&lt; will_delete-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新尾指针</span></span><br><span class="line"><span class="keyword">if</span> (i == m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;说明删除的是尾结点,需要更新尾指针&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_rear = p_curr;</span><br><span class="line"><span class="keyword">if</span> (m_rear-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;更新尾结点成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m_length--;<span class="comment">//表长-1</span></span><br><span class="line"><span class="comment">// 释放删除的结点</span></span><br><span class="line"><span class="keyword">delete</span> will_delete;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得第i个位置的元素,返回值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Link_List&lt;T&gt;::<span class="built_in">Get_Link_List_Elem</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前单链表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span></span><br><span class="line">&lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span></span><br><span class="line">&lt;&lt; p_curr-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> p_curr-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得第i个位置的元素,返回指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Node&lt;T&gt;* Link_List&lt;T&gt;::<span class="built_in">Get_Link_List_point</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p_curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照元素值查找链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Link_List&lt;T&gt;::<span class="built_in">Locate_Link_List_Elem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; i++)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p_curr-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p_curr-&gt;data == e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单链表中第一次出现的位置为&quot;</span></span><br><span class="line">&lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单链表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出链表所有的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">Display_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;* p = m_head;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;单链表所有元素展示：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; i++)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_length</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Link_List&lt;T&gt;::<span class="built_in">Link_List_Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_head-&gt;next == <span class="literal">nullptr</span>) <span class="comment">//单链表为空（如果是不带头结点的单</span></span><br><span class="line"><span class="comment">//链表则用if(m_head == nullptr）来判断是否为空）</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;单链表不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转链表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">Reverse_Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果没有顺序表中没有元素或者只有一个元素，那么就不用做任何操作</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p2 = m_head-&gt;next-&gt;next;<span class="comment">// 获取指向第二个结点的指针域</span></span><br><span class="line">m_head-&gt;next-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//将第一个结点的指针域赋值为空（作为最后一个结点）</span></span><br><span class="line">m_rear = m_head-&gt;next;<span class="comment">//更新尾指针</span></span><br><span class="line"></span><br><span class="line">Node&lt;T&gt;* p_curr;</span><br><span class="line"><span class="comment">// 只要改变第二个结点的指针域指向，便可改变顺序</span></span><br><span class="line"><span class="comment">// 具体步骤和头插法一致</span></span><br><span class="line"><span class="keyword">while</span> (p2 != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p_curr = p2;<span class="comment">//当前（假设a2)赋给p_curr指针进行插入操作</span></span><br><span class="line">p2 = p2-&gt;next;<span class="comment">//更新结点</span></span><br><span class="line"></span><br><span class="line">p_curr-&gt;next = m_head-&gt;next;</span><br><span class="line">m_head-&gt;next = p_curr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数进行释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Link_List&lt;T&gt;::~<span class="built_in">Link_List</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 对链表中的每个结点都需要进行释放</span></span><br><span class="line">Node&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">Node&lt;T&gt;* ptemp;</span><br><span class="line"><span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">ptemp = pnode;</span><br><span class="line">pnode = pnode-&gt;next;<span class="comment">//更新结点</span></span><br><span class="line"><span class="keyword">delete</span> ptemp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> m_head;</span><br><span class="line">m_head = <span class="literal">nullptr</span>;</span><br><span class="line">m_rear = <span class="literal">nullptr</span>;</span><br><span class="line">m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Link_List&lt;T&gt;::<span class="built_in">rear</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; 链表最后一个元素为&quot;</span> &lt;&lt; m_rear-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);<span class="comment">//程序退出时检测内存泄漏并显示到“输出”窗口</span></span><br><span class="line">_nmsp::Link_List&lt;<span class="type">int</span>&gt; Creat_link;</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Link_List_Insert</span>(<span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> length = Creat_link.<span class="built_in">Link_List_length</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;单链表长度为&quot;</span> &lt;&lt; length &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Reverse_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Get_Link_List_Elem</span>(<span class="number">3</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Empty</span>();</span><br><span class="line">Creat_link.<span class="built_in">Locate_Link_List_Elem</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Creat_link.<span class="built_in">Link_List_Delete</span>(<span class="number">6</span>);</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line"></span><br><span class="line">_nmsp::Node&lt;<span class="type">int</span>&gt;* node = Creat_link.<span class="built_in">Get_Link_List_point</span>(<span class="number">4</span>);</span><br><span class="line">Creat_link.<span class="built_in">Link_List_Prior_Insert_Node</span>(<span class="number">1000</span>, node);</span><br><span class="line">Creat_link.<span class="built_in">Display_Link_List</span>();</span><br><span class="line">Creat_link.<span class="built_in">rear</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线性表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表的实现（c++）</title>
      <link href="/archives/b4bd089e.html"/>
      <url>/archives/b4bd089e.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是顺序表"><a href="#什么是顺序表" class="headerlink" title="什么是顺序表"></a>什么是顺序表</h1><ul><li>一个最简单的例子就是一维数组，它的特点就是在内存中进行<strong>顺序存储</strong></li><li>在一块内存中，进行顺序存储的线性表就是顺序表</li><li>在任意时刻，数组的长度就是顺序表的最大存储容量</li></ul><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG<span class="comment">//只有在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__)<span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="comment">//当进行对象转储时，用 DEBUG_NEW 分配的每个对象均将显示被分配到的文件和行号，使您可以查明内存泄漏源</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW    </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10<span class="comment">//动态数组的初始大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IncSize 5<span class="comment">//当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span></span><br></pre></td></tr></table></figure><hr><h1 id="顺序表的数据成员-两种写法"><a href="#顺序表的数据成员-两种写法" class="headerlink" title="顺序表的数据成员(两种写法)"></a>顺序表的数据成员(两种写法)</h1><ul><li><p>静态数组</p><ul><li><p>建立一个一维数组，来保存顺序表的元素</p></li><li><p>建立一个变量存储顺序表当前的实际长度（不是数组的长度，数组长度是已知的）</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_data[<span class="number">10</span>];  <span class="comment">//静态数组保存顺序表中的元素，一共10个位置</span></span><br><span class="line"><span class="type">int</span> m_length;<span class="comment">//顺序表中当前的实际长度</span></span><br><span class="line"></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure><ul><li>动态数组（通常都采用这种写法）<ul><li>用指针进行建立数组内存</li><li>动态数组可以进行扩容</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>* m_data;       <span class="comment">//顺序表中的元素保存在m_data所指向的动态数组内存中</span></span><br><span class="line"><span class="type">int</span> m_length;<span class="comment">//顺序表当前的实际长度</span></span><br><span class="line"><span class="type">int</span> m_maxsize;<span class="comment">//动态数组最大容量，因为动态数组可以扩容，因此要记录该值</span></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure><hr><h1 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h1><ul><li>顺序表的类的定义和设计<ul><li>构造函数</li><li>析构函数</li><li>按指定位置i插入元素</li><li>按指定位置i删除元素</li><li>获取第i位置的元素</li><li>按元素值查找在顺序表的第一次出现的位置</li><li>遍历输出顺序表的元素</li><li>获取顺序表的长度</li><li>反转顺序表</li><li>扩容操作</li></ul></li></ul><hr><h1 id="顺序表的编程实现"><a href="#顺序表的编程实现" class="headerlink" title="顺序表的编程实现"></a>顺序表的编程实现</h1><h2 id="类（顺序表-定义"><a href="#类（顺序表-定义" class="headerlink" title="类（顺序表)定义"></a>类（顺序表)定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SeqList</span>(<span class="type">int</span> length = InitSize);<span class="comment">//构造函数</span></span><br><span class="line">~<span class="built_in">SeqList</span>();<span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List_Insert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//在第i个位置插入新元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List_Delete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Get_List_Elem</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//获取第i个位置的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Locate_Elem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//按元素值查找在顺序表的第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display_List</span><span class="params">()</span></span>;<span class="comment">//输出顺序表中的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_List_Length</span><span class="params">()</span></span>;<span class="comment">//获取顺序表的长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse_List</span><span class="params">()</span></span>;<span class="comment">//反转顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increase_Size</span><span class="params">()</span></span>;<span class="comment">//扩容操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_data;<span class="comment">//（指向存放顺序表的当中的元素</span></span><br><span class="line"><span class="type">int</span> m_length;<span class="comment">//顺序表中当前实际长度（当前有几个元素）</span></span><br><span class="line"><span class="type">int</span> m_maxsize;<span class="comment">//动态数组的最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="构造函数（初始化）"><a href="#构造函数（初始化）" class="headerlink" title="构造函数（初始化）"></a>构造函数（初始化）</h2><ul><li>首先会开辟一块内存来存储顺序表</li><li>为当前顺序表长度赋初值为0</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数对顺序表进行初始化template &lt;typename T&gt;</span></span><br><span class="line">SeqList&lt;T&gt;::<span class="built_in">SeqList</span>(<span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">m_data = <span class="keyword">new</span> T[length]; <span class="comment">//为一维数组动态分配内存</span></span><br><span class="line">m_length = <span class="number">0</span>;           <span class="comment">//顺序表当前实际长度为0，表示还未向其中存入任何数据元素</span></span><br><span class="line">m_maxsize = length;     <span class="comment">//顺序表最多可以存储m_maxsize个数据元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul><li>必须对用户自己分配好的内存空间进行释放</li><li><strong>delete m_data 和delete []m_data的区别</strong><ul><li>delete m_data <strong>释放了m_data指针指向的全部内存空间 但是只调用了m_data[0]对象的析构函数 剩下的从[1]到末尾这个用户自行分配的对应内存空间将不能释放</strong>， 从而造成内存泄漏。</li><li>delete []m_data <strong>&#x2F;调用使用类对象的析构函数释放用户自己分配内存空间并且  释放了m_data指针指向的全部内存空间</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过析构函数对顺序表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqList&lt;T&gt;::~<span class="built_in">SeqList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">m_length = <span class="number">0</span>; <span class="comment">//非必须</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="按指定位置i插入元素"><a href="#按指定位置i插入元素" class="headerlink" title="按指定位置i插入元素"></a>按指定位置i插入元素</h2><ol><li><p>先判断顺序表是否存满数据；是，进行扩容操作</p></li><li><p>判断i这个位置是否合法</p></li><li><p>以上都满足进行插入操作</p><ul><li><p>从最后一个元素遍历到下标为i的位置（也就是第i+1个元素）结束进行元素位置向后移位</p></li><li><p>对第i个位置进行赋值</p></li><li><p>每一次进行插入 操作，顺序表长+1</p></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在第i个位置（位置编号从1开始）插入指定元素e，时间复杂度：O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果顺序表已经存满了数据，则不允许再插入新数据了</span></span><br><span class="line"><span class="keyword">if</span> (m_length &gt;= m_maxsize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;顺序表已满，不能再进行插入操作了!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="built_in">IncreaseSize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断插入位置i是否合法，i的合法值应该是1到m_length+1之间</span></span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; (m_length+<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt;<span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt;   m_length+<span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从最后一个元素开始向前遍历到要插入新元素的第i个位置，</span></span><br><span class="line"><span class="comment">//分别将这些位置中原有的元素向后移动一个位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = m_length; j &gt;= i; --j) </span><br><span class="line">&#123;</span><br><span class="line">m_data[j] = m_data[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">m_data[i<span class="number">-1</span>] = e;   <span class="comment">//在指定位置i处插入元素e</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;        <span class="comment">//实际表长+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="按指定位置i删除元素"><a href="#按指定位置i删除元素" class="headerlink" title="按指定位置i删除元素"></a>按指定位置i删除元素</h2><ul><li>判断表是否为空</li><li>判断位置i是否合法</li><li>以上都满足，遍历第i+1个位置到顺序表末尾向前移位</li><li>每次删除操作顺序表长都必须-1</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序表为空，不能删除任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//从数组中第i+1个位置开始向后遍历所有元素，分别将这些位置中原有的元素向前移动一个位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i ; j &lt; m_length; ++j)</span><br><span class="line">&#123;</span><br><span class="line">m_data[j<span class="number">-1</span>] = m_data[j];</span><br><span class="line">&#125;</span><br><span class="line">m_length--;       <span class="comment">//实际表长-1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="获取第i个位置的元素值"><a href="#获取第i个位置的元素值" class="headerlink" title="获取第i个位置的元素值"></a>获取第i个位置的元素值</h2><ul><li>判断表是否为空</li><li>判断位置i是否合法</li><li>以上都满足，成功获取值</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e) <span class="comment">//参数e是引用类型参数，确保将该值带回调用者</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt;   <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = m_data[i<span class="number">-1</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="按元素值查找在顺序表的第一次出现的位置"><a href="#按元素值查找在顺序表的第一次出现的位置" class="headerlink" title="按元素值查找在顺序表的第一次出现的位置"></a>按元素值查找在顺序表的第一次出现的位置</h2><ul><li>是按照元素值进行查找，则对其全部进行遍历一一对比</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按元素值查找其在顺序表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_data[i] == e)</span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在顺序表中第一次出现的位置为&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">//返回的位置应该用数组下标值+1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在顺序表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="遍历输出顺序表的元素"><a href="#遍历输出顺序表的元素" class="headerlink" title="遍历输出顺序表的元素"></a>遍历输出顺序表的元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出顺序表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="获取顺序表的长度"><a href="#获取顺序表的长度" class="headerlink" title="获取顺序表的长度"></a>获取顺序表的长度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取顺序表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="反转顺序表"><a href="#反转顺序表" class="headerlink" title="反转顺序表"></a>反转顺序表</h2><ul><li>判断顺序是否为空</li><li>第一个和最后一个交换赋值，依次类推</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//翻转顺序表，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">ReverseList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果没有顺序表中没有元素或者只有一个元素，那么就不用做任何操作</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">T temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length / <span class="number">2</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">temp = m_data[i];</span><br><span class="line">m_data[i] = m_data[m_length - i - <span class="number">1</span>];</span><br><span class="line">m_data[m_length - i - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h2><ul><li>新建一个指针指向原来顺序表的数据的内存块</li><li>新开辟一个内存的同时要扩容一下大小</li><li>然后在遍历原来内存将其数据复制到已经新的内存（新扩容的内存）</li><li>释放原来的内存块</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当顺序表存满数据后可以调用此函数为顺序表扩容，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">IncreaseSize</span>()</span><br><span class="line">&#123;</span><br><span class="line">T* p = m_data;</span><br><span class="line">m_data = <span class="keyword">new</span> T[m_maxsize + IncSize]; <span class="comment">//重新为顺序表分配更大的内存空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; i++)</span><br><span class="line">&#123;</span><br><span class="line">m_data[i] = p[i];                <span class="comment">//将数据复制到新区域</span></span><br><span class="line">&#125;</span><br><span class="line">m_maxsize = m_maxsize + IncSize;     <span class="comment">//顺序表最大长度增加IncSize</span></span><br><span class="line"><span class="keyword">delete</span>[] p;                          <span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主函数操作"><a href="#主函数操作" class="headerlink" title="主函数操作"></a>主函数操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line"><span class="comment">//程序退出时检测内存泄漏并显示到“输出”窗口</span></span><br><span class="line"></span><br><span class="line"><span class="function">_nmsp1::SeqList&lt;<span class="type">int</span>&gt; <span class="title">seqobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">30</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">seqobj.<span class="built_in">ListDelete</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">seqobj.<span class="built_in">GetElem</span>(<span class="number">1</span>, eval); <span class="comment">//如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> findvalue = <span class="number">10</span>; <span class="comment">//在顺序表中要找的元素值</span></span><br><span class="line">seqobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">seqobj.<span class="built_in">DispList</span>();</span><br><span class="line">cout &lt;&lt; seqobj.<span class="built_in">ListLength</span>() &lt;&lt; endl;</span><br><span class="line">seqobj.<span class="built_in">ReverseList</span>();</span><br><span class="line">seqobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">30</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(i, i*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">seqobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>顺序表的特点</p><ul><li>通过下标访问数据元素的时间复杂度为O（1）</li><li>插入和删除操作会移动大量元素时间复杂度为O（n）</li><li>需要大片的连续的内存空间来存储数据</li><li>扩容操作的具体数值的大小不好确定（大了导致内存浪费，小了会进行频繁的操作）</li></ul></li><li><p>应用：</p><ul><li>vector  大致思想原理是类似于顺序表</li></ul></li></ul><hr><h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG   <span class="comment">//只在Debug（调试）模式下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) <span class="comment">//重新定义new运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &lt;boost/type_index.hpp&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#pragma warning(disable : 4996) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10   <span class="comment">//动态数组的初始尺寸</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IncSize  5    <span class="comment">//当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//T代表数组中元素的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SeqList</span>(<span class="type">int</span> length=InitSize); <span class="comment">//构造函数，参数可以有默认值</span></span><br><span class="line">~<span class="built_in">SeqList</span>();                   <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">//在第i个位置插入指定元素e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;              <span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;           <span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T &amp;e)</span></span>;         <span class="comment">//按元素值查找其在顺序表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;                     <span class="comment">//输出顺序表中的所有元素</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">ListLength</span><span class="params">()</span></span>;                   <span class="comment">//获取顺序表的长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReverseList</span><span class="params">()</span></span>;                  <span class="comment">//翻转顺序表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">()</span></span>;                 <span class="comment">//当顺序表存满数据后可以调用此函数为顺序表扩容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T*  m_data;                   <span class="comment">//存放顺序表中的元素</span></span><br><span class="line"><span class="type">int</span> m_length;                 <span class="comment">//顺序表当前长度（当前有几个元素）</span></span><br><span class="line"><span class="type">int</span> m_maxsize;                <span class="comment">//动态数组最大容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数对顺序表进行初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqList&lt;T&gt;::<span class="built_in">SeqList</span>(<span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">m_data = <span class="keyword">new</span> T[length]; <span class="comment">//为一维数组动态分配内存</span></span><br><span class="line">m_length = <span class="number">0</span>;           <span class="comment">//顺序表当前实际长度为0，表示还未向其中存入任何数据元素</span></span><br><span class="line">m_maxsize = length;     <span class="comment">//顺序表最多可以存储m_maxsize个数据元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对顺序表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqList&lt;T&gt;::~<span class="built_in">SeqList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">m_length = <span class="number">0</span>; <span class="comment">//非必须</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置（位置编号从1开始）插入指定元素e，时间复杂度：O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_length &gt;= m_maxsize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;顺序表已满，不能再进行插入操作了!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//return false;</span></span><br><span class="line"><span class="built_in">IncreaseSize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; (m_length+<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt;<span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length+<span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = m_length; j &gt;= i; --j) </span><br><span class="line">&#123;</span><br><span class="line">m_data[j] = m_data[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">m_data[i<span class="number">-1</span>] = e;   </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_length++;        <span class="comment">//实际表长+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序表为空，不能删除任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i ; j &lt; m_length; ++j)</span><br><span class="line">&#123;</span><br><span class="line">m_data[j<span class="number">-1</span>] = m_data[j];</span><br><span class="line">&#125;</span><br><span class="line">m_length--;       <span class="comment">//实际表长-1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e) <span class="comment">//参数e是引用类型参数，确保将该值带回调用者</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前顺序表为空，不能获取任何数据!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">e = m_data[i<span class="number">-1</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按元素值查找其在顺序表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_data[i] == e)</span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在顺序表中第一次出现的位置为&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">//返回的位置应该用数组下标值+1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在顺序表中没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出顺序表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//每个数据之间以空格分隔</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取顺序表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//翻转顺序表，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">ReverseList</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">T temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length / <span class="number">2</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">temp = m_data[i];</span><br><span class="line">m_data[i] = m_data[m_length - i - <span class="number">1</span>];</span><br><span class="line">m_data[m_length - i - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当顺序表存满数据后可以调用此函数为顺序表扩容，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">IncreaseSize</span>()</span><br><span class="line">&#123;</span><br><span class="line">T* p = m_data;</span><br><span class="line">m_data = <span class="keyword">new</span> T[m_maxsize + IncSize]; <span class="comment">//重新为顺序表分配更大的内存空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; i++)</span><br><span class="line">&#123;</span><br><span class="line">m_data[i] = p[i];                <span class="comment">//将数据复制到新区域</span></span><br><span class="line">&#125;</span><br><span class="line">m_maxsize = m_maxsize + IncSize;     <span class="comment">//顺序表最大长度增加IncSize</span></span><br><span class="line"><span class="keyword">delete</span>[] p;                          <span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//程序退出时检测内存泄漏并显示到“输出”窗口</span></span><br><span class="line">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</span><br><span class="line"></span><br><span class="line"><span class="function">_nmsp1::SeqList&lt;<span class="type">int</span>&gt; <span class="title">seqobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">30</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">seqobj.<span class="built_in">ListDelete</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">seqobj.<span class="built_in">GetElem</span>(<span class="number">1</span>, eval); <span class="comment">//如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> findvalue = <span class="number">10</span>; <span class="comment">//在顺序表中要找的元素值</span></span><br><span class="line">seqobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">seqobj.<span class="built_in">DispList</span>();</span><br><span class="line">cout &lt;&lt; seqobj.<span class="built_in">ListLength</span>() &lt;&lt; endl;</span><br><span class="line">seqobj.<span class="built_in">ReverseList</span>();</span><br><span class="line">seqobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">30</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">seqobj.<span class="built_in">ListInsert</span>(i, i*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">seqobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线性表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Github+hexo教程</title>
      <link href="/archives/ce550664.html"/>
      <url>/archives/ce550664.html</url>
      
        <content type="html"><![CDATA[<h1 id="搭建GitHub-hexo的博客"><a href="#搭建GitHub-hexo的博客" class="headerlink" title="搭建GitHub+hexo的博客"></a>搭建GitHub+hexo的博客</h1><h2 id="什么是hexo"><a href="#什么是hexo" class="headerlink" title="什么是hexo"></a>什么是hexo</h2><ul><li><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，说的简单一点就是hexo具有markdown程序转换成HTML页面 </p></li><li><p>一般在自己电脑上会创建一个blog文件夹来作为本地仓库，github创建一个仓库，由本地部署到GitHub上面即可通过网址来进行访问。</p></li></ul><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li><p>事先看一遍b站视频</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1mU4y1j72n/spm_id_from=333.337.search-card.all.click   多看看这个视频的准备工作</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.999.0.0</span><br><span class="line">看这个过程进行一步一步的操作</span><br></pre></td></tr></table></figure></li><li><p>安装git （会用的git bash命令行进行操作）  </p></li><li><p>上GitHub官网申请一个账号（并且创建一个仓库）具体操作看第一个视频</p></li><li><p>安装node.js(选择长期版本的)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v  </span><br><span class="line">npm  -v</span><br><span class="line">//显示版本就代表安装成功</span><br><span class="line">npm是一个软件包管理器，在国内速度很慢因此安装cnpm并把指向国内淘宝的镜像源也就是第五步</span><br></pre></td></tr></table></figure></li><li><p>安装cnpm并指向淘宝镜像源</p><p>1. </p>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><p>   <img src="/archives/ce550664/111.png"></p></li></ol><p>安装成功</p><hr><p>出现这种情况，再来一次上面这个命令</p><p><img src="/archives/ce550664/222.png"></p><hr><p><img src="/archives/ce550664/333.png"></p><p>删除c盘下的npmrc文件！！！！ 记住是c盘下的。</p><p>然后在重复命令。</p><hr><ol><li><p>安装hexo框架</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo -cli</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo -v </span><br><span class="line">//显示版本号安装成功</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="搭建本地仓库"><a href="#搭建本地仓库" class="headerlink" title="搭建本地仓库"></a>搭建本地仓库</h1><ol><li><p>建立Blog文件夹（随便在那儿建立，但必须保证是空）</p></li><li><p>在Blog文件下打开git bash</p></li><li><p>hexo init（进行初始化，blog文件夹会显示一系列文件）</p></li><li><p>hexo s</p></li></ol><p><img src="/archives/ce550664/444.png"></p><p>在浏览器输入红色部分会得到一个静态网页。</p><ol start="5"><li><p>hexo n “川的第一篇博客”(创建一个博客，在blog&#x2F;source&#x2F;_posts可以对其文档修改)</p></li><li><p>hexo clean(清理一下缓存)</p></li><li><p>hexo g（生成静态网页）</p></li><li><p>hexo s（运行服务器）</p></li></ol><hr><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><ol><li><p>建立github仓库成功之后</p></li><li><p>在blog文文件夹下装一个部署的插件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li><li><p>修改blog文件夹下的配置文件_config.yml</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">看到<span class="comment">#Deloyment这里进行修改如下图</span></span><br></pre></td></tr></table></figure><p><img src="/archives/ce550664/555.png"></p></li><li><p>hexo d（部署成功）</p></li></ol><hr><hr><h1 id="解决图片不显示问题"><a href="#解决图片不显示问题" class="headerlink" title="解决图片不显示问题"></a>解决图片不显示问题</h1><ul><li>更改配置文件_config.yml</li></ul><p><img src="/archives/ce550664/666.jpg"></p><ul><li>在hexo n ”  xxxx “新建一个博客时，就会产生一个xxxx的文件夹来存储图片以便于在md文件中进行引用图片。</li></ul><p><img src="/archives/ce550664/777.jpg"></p><ul><li><p>再更改一个插件 hexo-asset-image </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/foreveryang321/hexo-asset-image.git --save</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>再按照部署条件进行操作</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
